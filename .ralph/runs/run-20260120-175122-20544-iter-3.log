OpenAI Codex v0.87.0 (research preview)
--------
workdir: /home/josh/Documents/Github/RIS_SIONNA
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: danger-full-access
reasoning effort: none
reasoning summaries: auto
session id: 019bdc98-eb1d-75d3-960f-e4ee16c39a1f
--------
user
# Build

You are an autonomous coding agent. Your task is to complete the work for exactly one story and record the outcome.

## Paths
- PRD: /home/josh/Documents/Github/RIS_SIONNA/.agents/tasks/prd-ris-lab.json
- AGENTS (optional): /home/josh/Documents/Github/RIS_SIONNA/AGENTS.md
- Progress Log: /home/josh/Documents/Github/RIS_SIONNA/.ralph/progress.md
- Guardrails: /home/josh/Documents/Github/RIS_SIONNA/.ralph/guardrails.md
- Guardrails Reference: /home/josh/Documents/Github/RIS_SIONNA/.agents/ralph/references/GUARDRAILS.md
- Context Reference: /home/josh/Documents/Github/RIS_SIONNA/.agents/ralph/references/CONTEXT_ENGINEERING.md
- Errors Log: /home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log
- Activity Log: /home/josh/Documents/Github/RIS_SIONNA/.ralph/activity.log
- Activity Logger: /home/josh/Documents/Github/RIS_SIONNA/ralph log
- No-commit: false
- Repo Root: /home/josh/Documents/Github/RIS_SIONNA
- Run ID: 20260120-175122-20544
- Iteration: 3
- Run Log: /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-3.log
- Run Summary: /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-3.md

## Global Quality Gates (apply to every story)
- python -m pytest

## Selected Story (Do not change scope)
ID: US-003
Title: Add CLI entrypoint for RIS Lab runs and validation

Story details:
### US-003: Add CLI entrypoint for RIS Lab runs and validation
Status: in_progress
Depends on: US-001, US-002

Description:
As a user, I want to run RIS Lab headlessly via python -m app ris so runs are reproducible.

Acceptance Criteria:
- [ ] Add CLI commands: python -m app ris run --config <path> --mode pattern|link and python -m app ris validate --config <path> --ref <file>
- [ ] Example: pattern run creates outputs/<run_id>/ with required artifacts (phase_map.png, pattern plots, metrics.json)
- [ ] Negative case: invalid mode selection returns a non-zero exit and a usage hint
- [ ] CLI logs include run_id, mode, and output directory


If the story details are empty or missing, STOP and report that the PRD story format could not be parsed.

## Rules (Non-Negotiable)
- Implement **only** the work required to complete the selected story.
- Complete all tasks associated with this story (and only this story).
- Do NOT ask the user questions.
- Do NOT change unrelated code.
- Do NOT assume something is unimplemented — confirm by reading code.
- Implement completely; no placeholders or stubs.
- If No-commit is true, do NOT commit or push changes.
- Do NOT edit the PRD JSON (status is handled by the loop).
- All changes made during the run must be committed (including updates to progress/logs).
 - Before committing, perform a final **security**, **performance**, and **regression** review of your changes.

## Your Task (Do this in order)
1. Read /home/josh/Documents/Github/RIS_SIONNA/.ralph/guardrails.md before any code changes.
2. Read /home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log for repeated failures to avoid.
3. Read /home/josh/Documents/Github/RIS_SIONNA/.agents/tasks/prd-ris-lab.json for global context (do not edit).
4. Fully audit and read all necessary files to understand the task end-to-end before implementing. Do not assume missing functionality.
5. If /home/josh/Documents/Github/RIS_SIONNA/AGENTS.md exists, follow its build/test instructions.
6. Implement only the tasks that belong to US-003.
7. Run verification commands listed in the story, the global quality gates, and in /home/josh/Documents/Github/RIS_SIONNA/AGENTS.md (if required).
8. If the project has a build or dev workflow, run what applies:
   - Build step (e.g., `npm run build`) if defined.
   - Dev server (e.g., `npm run dev`, `wrangler dev`) if it is the normal validation path.
   - Confirm no runtime/build errors in the console.
9. Perform a brief audit before committing:
   - **Security:** check for obvious vulnerabilities or unsafe handling introduced by your changes.
   - **Performance:** check for avoidable regressions (extra queries, heavy loops, unnecessary re-renders).
   - **Regression:** verify existing behavior that could be impacted still works.
10. If No-commit is false, commit changes using the `$commit` skill.
    - Stage everything: `git add -A`
    - Confirm a clean working tree after commit: `git status --porcelain` should be empty.
    - After committing, capture the commit hash and subject using:
      `git show -s --format="%h %s" HEAD`.
11. Append a progress entry to /home/josh/Documents/Github/RIS_SIONNA/.ralph/progress.md with run/commit/test details (format below).
    If No-commit is true, skip committing and note it in the progress entry.

## Progress Entry Format (Append Only)
```
## [Date/Time] - US-003: Add CLI entrypoint for RIS Lab runs and validation
Thread: [codex exec session id if available, otherwise leave blank]
Run: 20260120-175122-20544 (iteration 3)
Run log: /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-3.log
Run summary: /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-3.md
- Guardrails reviewed: yes
- No-commit run: false
- Commit: <hash> <subject> (or `none` + reason)
- Post-commit status: `clean` or list remaining files
- Verification:
  - Command: <exact command> -> PASS/FAIL
  - Command: <exact command> -> PASS/FAIL
- Files changed:
  - <file path>
  - <file path>
- What was implemented
- **Learnings for future iterations:**
  - Patterns discovered
  - Gotchas encountered
  - Useful context
---
```

## Completion Signal
Only output the completion signal when the **selected story** is fully complete and verified.
When the selected story is complete, output:
<promise>COMPLETE</promise>

Otherwise, end normally without the signal.

## Additional Guardrails
- When authoring documentation, capture the why (tests + implementation intent).
- If you learn how to run/build/test the project, update /home/josh/Documents/Github/RIS_SIONNA/AGENTS.md briefly (operational only).
- Keep AGENTS operational only; progress notes belong in /home/josh/Documents/Github/RIS_SIONNA/.ralph/progress.md.
- If you hit repeated errors, log them in /home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log and add a Sign to /home/josh/Documents/Github/RIS_SIONNA/.ralph/guardrails.md using /home/josh/Documents/Github/RIS_SIONNA/.agents/ralph/references/GUARDRAILS.md as the template.

## Activity Logging (Required)
Log major actions to /home/josh/Documents/Github/RIS_SIONNA/.ralph/activity.log using the helper:
```
/home/josh/Documents/Github/RIS_SIONNA/ralph log "message"
```
Log at least:
- Start of work on the story
- After major code changes
- After tests/verification
- After updating progress log

## Browser Testing (Required for Frontend Stories)
If the selected story changes UI, you MUST verify it in the browser:
1. Load the `dev-browser` skill.
2. Navigate to the relevant page.
3. Verify the UI changes work as expected.
4. Take a screenshot if helpful for the progress log.

A frontend story is NOT complete until browser verification passes.

mcp: memory starting
mcp: context7 starting
mcp: filesystem starting
mcp: filesystem ready
mcp: context7 ready
mcp: memory ready
mcp startup: ready: filesystem, context7, memory

thinking
**Logging action start**

I'm preparing to log the start of an action and will use shell commands as part of the process.
exec
/usr/bin/zsh -lc '/home/josh/Documents/Github/RIS_SIONNA/ralph log "Start US-003 work"' in /home/josh/Documents/Github/RIS_SIONNA exited 127 in 2ms:
zsh:1: no such file or directory: /home/josh/Documents/Github/RIS_SIONNA/ralph

thinking
**Noticing command failure and planning error investigation**

The command failed for the first time, so I need to locate or create a script named "ralph" or a related logging tool to capture error details for troubleshooting.
exec
/usr/bin/zsh -lc 'ls -la' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 3ms:
total 108
drwxrwxr-x 16 josh josh  4096 Jan 20 18:01 .
drwxrwxr-x  3 josh josh  4096 Jan 19 17:55 ..
drwxrwxr-x  4 josh josh  4096 Jan 20 17:19 .agents
-rw-rw-r--  1 josh josh  7343 Jan 20 17:42 AGENTS.md
drwxrwxr-x  6 josh josh  4096 Jan 19 20:19 app
drwxrwxr-x  4 josh josh  4096 Jan 19 23:11 build
drwxrwxr-x  3 josh josh  4096 Jan 20 16:20 .codex
drwxrwxr-x  2 josh josh  4096 Jan 19 23:02 configs
drwxrwxr-x  2 josh josh  4096 Jan 19 20:03 docs
drwxrwxr-x  8 josh josh  4096 Jan 20 18:09 .git
-rw-rw-r--  1 josh josh    45 Jan 19 17:55 .gitignore
-rw-rw-r--  1 josh josh   228 Jan 19 17:55 Makefile
drwxrwxr-x  7 josh josh  4096 Jan 20 16:23 outputs
-rw-rw-r--  1 josh josh  4736 Jan 19 23:04 PROJECT_CONTEXT.md
-rw-rw-r--  1 josh josh   749 Jan 19 17:55 pyproject.toml
drwxrwxr-x  3 josh josh  4096 Jan 20 18:01 .pytest_cache
drwxrwxr-x  4 josh josh  4096 Jan 20 17:51 .ralph
-rw-rw-r--  1 josh josh 11803 Jan 20 17:37 README.md
-rw-rw-r--  1 josh josh   649 Jan 19 23:04 REPO_STATUS.md

thinking
**Searching for activity logging scripts**
exec
/usr/bin/zsh -lc "rg --files -g 'ralph'" in /home/josh/Documents/Github/RIS_SIONNA exited 1 in 5ms:


thinking
**Investigating missing helper executable**

The expected helper executable or log file for "ralph" is missing; checking if "ralph" is available in PATH or located in .agents next.
exec
/usr/bin/zsh -lc "rg --files -g '*ralph*'" in /home/josh/Documents/Github/RIS_SIONNA exited 1 in 6ms:


thinking
**Checking for helper and logging errors**

I'm verifying if the helper script exists as instructed, considering logging missing helper errors in errors.log while guarding against repeated logs. I'll also check the .ralph directory for any additional instructions.
exec
/usr/bin/zsh -lc 'ls -la .ralph' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 3ms:
total 32
drwxrwxr-x  4 josh josh 4096 Jan 20 17:51 .
drwxrwxr-x 16 josh josh 4096 Jan 20 18:01 ..
-rw-rw-r--  1 josh josh 1252 Jan 20 18:09 activity.log
-rw-rw-r--  1 josh josh  412 Jan 20 18:09 errors.log
-rw-rw-r--  1 josh josh  421 Jan 20 17:51 guardrails.md
-rw-rw-r--  1 josh josh 3088 Jan 20 18:08 progress.md
drwxrwxr-x  2 josh josh 4096 Jan 20 18:09 runs
drwxrwxr-x  2 josh josh 4096 Jan 20 18:09 .tmp

thinking
**Considering fallback logging approach**

Since the required helper is missing, I'll check if it can be found in the PATH before resorting to manual appending to activity.log, and consider logging the issue in errors.log to note the problem while continuing.
exec
/usr/bin/zsh -lc 'which ralph' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 2ms:
/home/josh/.npm-global/bin/ralph

thinking
**Handling missing helper path**

The explicit helper path is missing, so I'll fall back to using the `ralph` command from PATH and log this discrepancy in errors.log as instructed.
exec
/usr/bin/zsh -lc 'ralph log "Start US-003 work"' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 87ms:
Using local templates: /home/josh/Documents/Github/RIS_SIONNA/.agents/ralph

thinking
**Considering error logging approach**

I'm debating logging the missing file error to avoid repeated logs but noting this is a single occurrence; next, I'll review the guardrails to clarify error logging policy.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.ralph/guardrails.md"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.ralph/guardrails.md"}) success in 3ms:
{
  "content": [
    {
      "text": "# Guardrails (Signs)\n\n> Lessons learned from failures. Read before acting.\n\n## Core Signs\n\n### Sign: Read Before Writing\n- **Trigger**: Before modifying any file\n- **Instruction**: Read the file first\n- **Added after**: Core principle\n\n### Sign: Test Before Commit\n- **Trigger**: Before committing changes\n- **Instruction**: Run required tests and verify outputs\n- **Added after**: Core principle\n\n---\n\n## Learned Signs\n\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "# Guardrails (Signs)\n\n> Lessons learned from failures. Read before acting.\n\n## Core Signs\n\n### Sign: Read Before Writing\n- **Trigger**: Before modifying any file\n- **Instruction**: Read the file first\n- **Added after**: Core principle\n\n### Sign: Test Before Commit\n- **Trigger**: Before committing changes\n- **Instruction**: Run required tests and verify outputs\n- **Added after**: Core principle\n\n---\n\n## Learned Signs\n\n"
  }
}

thinking
**Reading error log**
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log"}) success in 1ms:
{
  "content": [
    {
      "text": "# Error Log\n\n> Failures and repeated issues. Use this to add guardrails.\n\n[2026-01-20 17:57:10] ITERATION 1 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-1.md\n[2026-01-20 18:09:25] ITERATION 2 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-2.md\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "# Error Log\n\n> Failures and repeated issues. Use this to add guardrails.\n\n[2026-01-20 17:57:10] ITERATION 1 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-1.md\n[2026-01-20 18:09:25] ITERATION 2 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-2.md\n"
  }
}

thinking
**Reading PRD JSON**
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.agents/tasks/prd-ris-lab.json"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.agents/tasks/prd-ris-lab.json"}) success in 1ms:
{
  "content": [
    {
      "text": "{\n  \"version\": 1,\n  \"project\": \"RIS Lab (Validation First)\",\n  \"overview\": \"Add a RIS Lab module to design and validate RIS behaviors against MATLAB and paper-style references with reproducible CLI and Simulator-UI runs, saving full artifacts for regression testing.\",\n  \"goals\": [\n    \"Provide deterministic RIS math, control synthesis, and pattern/link validation via CLI and Simulator UI\",\n    \"Reproduce MATLAB reference patterns within configurable RMSE + peak-angle thresholds\",\n    \"Persist all run artifacts under outputs/<run_id>/ for regression tracking\"\n  ],\n  \"nonGoals\": [\n    \"Ray tracing or Sionna RT RIS integration (no ray-traced RIS scattering)\",\n    \"RIS optimization, auto-tuning, or search algorithms\",\n    \"GIS or map ingestion\"\n  ],\n  \"successMetrics\": [\n    \"A validation run matches MATLAB pattern within RMSE threshold and peak-angle error threshold\",\n    \"A run produces all required artifacts under outputs/<run_id>/\"\n  ],\n  \"openQuestions\": [],\n  \"defaults\": {\n    \"validation\": {\n      \"normalization\": \"peak_0db\",\n      \"rmse_db_max\": 2.0,\n      \"peak_angle_err_deg_max\": 2.0,\n      \"peak_db_err_max\": 1.5\n    },\n    \"experiment\": {\n      \"frequency_hz\": 28000000000,\n      \"tx_incident_angle_deg\": -30,\n      \"rx_sweep_deg\": {\n        \"start\": -90,\n        \"stop\": 90,\n        \"step\": 2\n      }\n    },\n    \"platform\": {\n      \"primary\": \"native_ubuntu_24_04_gpu\",\n      \"wsl\": \"cpu_only_unsupported_for_optix\"\n    }\n  },\n  \"stack\": {\n    \"framework\": \"Python 3.10\\u20133.12 with existing app CLI and Simulator UI (sim_server + sim_web)\",\n    \"hosting\": \"Local app execution\",\n    \"database\": \"None (filesystem outputs)\",\n    \"auth\": \"None\"\n  },\n  \"routes\": [\n    {\n      \"path\": \"/sim\",\n      \"name\": \"Simulator\",\n      \"purpose\": \"Host RIS Lab tab with Config/Run/Results sub-tabs\"\n    }\n  ],\n  \"uiNotes\": [\n    \"RIS Lab tab contains sub-tabs: Config, Run, Results\",\n    \"UI must show progress and logs and remain responsive during runs (background jobs only)\",\n    \"All UI actions must be reproducible via CLI using the same config schema\",\n    \"UI must be hosted in the Simulator surface (sim_server/sim_web), not Streamlit dashboard\"\n  ],\n  \"dataModel\": [\n    {\n      \"entity\": \"RisLabConfig\",\n      \"fields\": [\n        \"id\",\n        \"ris_geometry\",\n        \"control_synthesis\",\n        \"quantization\",\n        \"pattern_mode\",\n        \"link_mode\",\n        \"validation\",\n        \"output\"\n      ]\n    },\n    {\n      \"entity\": \"RisRun\",\n      \"fields\": [\n        \"run_id\",\n        \"started_at\",\n        \"status\",\n        \"mode\",\n        \"artifacts\",\n        \"metrics\",\n        \"errors\"\n      ]\n    },\n    {\n      \"entity\": \"ReferenceData\",\n      \"fields\": [\n        \"theta_deg\",\n        \"pattern_db\",\n        \"pattern_linear\",\n        \"meta\"\n      ]\n    }\n  ],\n  \"importFormat\": {\n    \"description\": \"Reference data with theta sweep and pattern in CSV (required), NPZ (optional), MAT (optional/stretch).\",\n    \"priority\": [\n      \"CSV\",\n      \"NPZ\",\n      \"MAT\"\n    ],\n    \"requiredFields\": {\n      \"theta_deg\": \"1D array of Rx sweep angles in degrees\",\n      \"pattern_db_or_linear\": \"Either pattern_db (dB) or pattern_linear (linear), same length as theta_deg\"\n    },\n    \"example\": {\n      \"csv\": {\n        \"columns\": [\n          \"theta_deg\",\n          \"pattern_db\"\n        ],\n        \"meta\": {\n          \"frequency_hz\": 28000000000,\n          \"tx_angle_deg\": -30,\n          \"ris_shape\": [\n            20,\n            20\n          ],\n          \"dx_m\": 0.0046,\n          \"dy_m\": 0.0046,\n          \"quantization_bits\": 1,\n          \"normalization\": \"peak_0db\"\n        }\n      }\n    }\n  },\n  \"rules\": [\n    \"Pattern mode supports normalized pattern vs Rx angle sweep and produces both linear and dB arrays\",\n    \"Default normalization is peak_0db (peak=0 dB); unit_power normalization is supported as an option\",\n    \"Link mode supports a canonical coherent sum with 1/(rt*rr) weighting and explicit phase convention; do not implement multiple competing equation variants in this PRD\",\n    \"Quantization supports continuous, 1-bit (0/pi), and 2-bit (0/pi/2/pi/3pi/2)\",\n    \"All run artifacts must be written to outputs/<run_id>/ with both config.yaml and config.json snapshots\",\n    \"No silent fallback: validation and run modes must log conventions and clearly report failures\"\n  ],\n  \"qualityGates\": [\n    \"python -m pytest\"\n  ],\n  \"stories\": [\n    {\n      \"id\": \"US-001\",\n      \"title\": \"Add ris_core math primitives and unit tests\",\n      \"status\": \"done\",\n      \"dependsOn\": [],\n      \"description\": \"As a developer, I want deterministic RIS geometry, phase synthesis, and quantization functions so validation runs are reproducible.\",\n      \"acceptanceCriteria\": [\n        \"Add a ris_core module under app/ris/ with geometry (element centers + local frame), phase synthesis (uniform, steering, focusing, custom), and quantization utilities\",\n        \"Example: for a known 2x2 RIS with dx=dy, geometry returns four element centers with expected spacing and stable ordering\",\n        \"Negative case: invalid quantization bits (e.g., 3) raises a clear validation error\",\n        \"Add unit tests covering geometry, frame construction, and quantization edge cases\",\n        \"python -m pytest passes\"\n      ],\n      \"startedAt\": \"2026-01-20T17:51:22.599335+00:00\",\n      \"completedAt\": \"2026-01-20T17:57:10.145050+00:00\",\n      \"updatedAt\": \"2026-01-20T17:57:10.145041+00:00\"\n    },\n    {\n      \"id\": \"US-002\",\n      \"title\": \"Define RIS Lab config schema and snapshot outputs\",\n      \"status\": \"done\",\n      \"dependsOn\": [\n        \"US-001\"\n      ],\n      \"description\": \"As a user, I want a YAML config for RIS Lab that resolves into canonical YAML+JSON snapshots in each run output.\",\n      \"acceptanceCriteria\": [\n        \"Add a RIS Lab config schema with defaults for geometry, control synthesis, quantization, pattern/link modes, and validation thresholds\",\n        \"Example: a minimal YAML config runs with defaults and writes outputs/<run_id>/config.yaml and outputs/<run_id>/config.json\",\n        \"Negative case: missing required fields (e.g., N/M or dx/dy) produces a clear error listing required fields\",\n        \"Config resolution is deterministic and recorded in run metadata (metrics.json or summary.json)\"\n      ],\n      \"startedAt\": \"2026-01-20T17:57:12.190815+00:00\",\n      \"completedAt\": \"2026-01-20T18:09:25.595908+00:00\",\n      \"updatedAt\": \"2026-01-20T18:09:25.595899+00:00\"\n    },\n    {\n      \"id\": \"US-003\",\n      \"title\": \"Add CLI entrypoint for RIS Lab runs and validation\",\n      \"status\": \"in_progress\",\n      \"dependsOn\": [\n        \"US-001\",\n        \"US-002\"\n      ],\n      \"description\": \"As a user, I want to run RIS Lab headlessly via python -m app ris so runs are reproducible.\",\n      \"acceptanceCriteria\": [\n        \"Add CLI commands: python -m app ris run --config <path> --mode pattern|link and python -m app ris validate --config <path> --ref <file>\",\n        \"Example: pattern run creates outputs/<run_id>/ with required artifacts (phase_map.png, pattern plots, metrics.json)\",\n        \"Negative case: invalid mode selection returns a non-zero exit and a usage hint\",\n        \"CLI logs include run_id, mode, and output directory\"\n      ],\n      \"startedAt\": \"2026-01-20T18:09:27.642152+00:00\",\n      \"completedAt\": null,\n      \"updatedAt\": \"2026-01-20T18:09:27.642160+00:00\"\n    },\n    {\n      \"id\": \"US-003A\",\n      \"title\": \"Wire RIS Lab into sim_jobs and sim_server for non-blocking UI runs\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-003\"\n      ],\n      \"description\": \"As a user, I want the Simulator UI to run RIS Lab jobs in the background using the existing job system.\",\n      \"acceptanceCriteria\": [\n        \"Add a ris_lab job type to the existing job runner (sim_jobs) with progress updates to progress.json\",\n        \"Expose an API endpoint in sim_server to start RIS Lab jobs and query status\",\n        \"Example: UI can start a RIS job and receive progress/log updates without blocking\",\n        \"Negative case: job failure surfaces an error message and preserves partial artifacts in outputs/<run_id>/\"\n      ]\n    },\n    {\n      \"id\": \"US-004\",\n      \"title\": \"Implement pattern mode artifacts and metrics\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-001\",\n        \"US-002\",\n        \"US-003\"\n      ],\n      \"description\": \"As a user, I want pattern mode to compute normalized patterns and save required artifacts and metrics.\",\n      \"acceptanceCriteria\": [\n        \"Pattern mode produces phase map, pattern arrays, and plots (Cartesian + polar) under outputs/<run_id>/\",\n        \"Artifacts include raw arrays (phase_map.npy, pattern_linear.npy, pattern_db.npy, theta_deg.npy or csv) and images\",\n        \"metrics.json includes peak angle, peak value, and a simple sidelobe metric (documented definition)\",\n        \"Negative case: mismatched theta array lengths are rejected with a clear error\"\n      ]\n    },\n    {\n      \"id\": \"US-005\",\n      \"title\": \"Add validation harness for CSV reference data\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-004\"\n      ],\n      \"description\": \"As a user, I want to validate pattern mode outputs against MATLAB CSV exports with PASS/FAIL metrics.\",\n      \"acceptanceCriteria\": [\n        \"Validation loads CSV with theta_deg + (pattern_db or pattern_linear) columns\",\n        \"Validation run creates overlay plot (reference vs sim) and error report containing RMSE and peak angle error\",\n        \"Negative case: CSV missing theta_deg or pattern column fails with a clear field list\",\n        \"PASS/FAIL result is written to metrics.json (or pass_fail.json) with threshold values used\"\n      ]\n    },\n    {\n      \"id\": \"US-006\",\n      \"title\": \"Add NPZ reference import support\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-005\"\n      ],\n      \"description\": \"As a user, I want to validate against NPZ exports when available.\",\n      \"acceptanceCriteria\": [\n        \"NPZ loader supports keys theta_deg + (pattern_db or pattern_linear)\",\n        \"NPZ validation produces the same overlay outputs as CSV validation\",\n        \"Negative case: missing keys cause a clear error listing expected keys\"\n      ]\n    },\n    {\n      \"id\": \"US-007\",\n      \"title\": \"Add MAT reference import (stretch)\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-005\"\n      ],\n      \"description\": \"As a user, I want optional MAT import support when easy to enable.\",\n      \"acceptanceCriteria\": [\n        \"If MAT import is enabled, document and add scipy as an optional dependency (extras)\",\n        \"Example: MAT file containing theta_deg + pattern_db validates and generates overlay plots\",\n        \"Negative case: when scipy is missing, CLI returns an actionable install message\"\n      ]\n    },\n    {\n      \"id\": \"US-008\",\n      \"title\": \"Add RIS Lab UI tab with Config/Run/Results\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-003A\",\n        \"US-004\",\n        \"US-005\"\n      ],\n      \"description\": \"As a user, I want a RIS Lab tab with sub-tabs for config, running, and results.\",\n      \"acceptanceCriteria\": [\n        \"RIS Lab tab appears in the existing Simulator UI with Config/Run/Results sub-tabs\",\n        \"Run tab starts a background job and updates progress/logs without blocking the UI\",\n        \"Results tab can load a completed run directory and display plots + metrics\",\n        \"Negative case: if a run fails, Results shows the error and preserves partial artifacts\"\n      ]\n    },\n    {\n      \"id\": \"US-009\",\n      \"title\": \"Add regression test fixture and validation tests\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-005\"\n      ],\n      \"description\": \"As a developer, I want a small golden fixture to keep validation metrics stable in CI.\",\n      \"acceptanceCriteria\": [\n        \"Add a small reference fixture (CSV) and a test that runs validation with known thresholds\",\n        \"Validation test asserts PASS and expected metric ranges\",\n        \"Negative case: intentionally perturbed data fails thresholds and reports FAIL\",\n        \"python -m pytest passes\"\n      ]\n    },\n    {\n      \"id\": \"US-010\",\n      \"title\": \"Document RIS Lab usage and config examples\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-003\",\n        \"US-004\",\n        \"US-005\",\n        \"US-008\"\n      ],\n      \"description\": \"As a user, I want clear docs and example configs to run RIS Lab from CLI and UI.\",\n      \"acceptanceCriteria\": [\n        \"README includes a RIS Lab section with CLI examples and required artifacts list\",\n        \"Add example configs under configs/ris/ (steer_1bit.yaml, focus_point.yaml, validate_vs_csv.yaml)\",\n        \"Docs warn that ray tracing RIS integration is out of scope and not enabled\",\n        \"Documentation describes CSV reference format and required fields\"\n      ]\n    }\n  ]\n}\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "{\n  \"version\": 1,\n  \"project\": \"RIS Lab (Validation First)\",\n  \"overview\": \"Add a RIS Lab module to design and validate RIS behaviors against MATLAB and paper-style references with reproducible CLI and Simulator-UI runs, saving full artifacts for regression testing.\",\n  \"goals\": [\n    \"Provide deterministic RIS math, control synthesis, and pattern/link validation via CLI and Simulator UI\",\n    \"Reproduce MATLAB reference patterns within configurable RMSE + peak-angle thresholds\",\n    \"Persist all run artifacts under outputs/<run_id>/ for regression tracking\"\n  ],\n  \"nonGoals\": [\n    \"Ray tracing or Sionna RT RIS integration (no ray-traced RIS scattering)\",\n    \"RIS optimization, auto-tuning, or search algorithms\",\n    \"GIS or map ingestion\"\n  ],\n  \"successMetrics\": [\n    \"A validation run matches MATLAB pattern within RMSE threshold and peak-angle error threshold\",\n    \"A run produces all required artifacts under outputs/<run_id>/\"\n  ],\n  \"openQuestions\": [],\n  \"defaults\": {\n    \"validation\": {\n      \"normalization\": \"peak_0db\",\n      \"rmse_db_max\": 2.0,\n      \"peak_angle_err_deg_max\": 2.0,\n      \"peak_db_err_max\": 1.5\n    },\n    \"experiment\": {\n      \"frequency_hz\": 28000000000,\n      \"tx_incident_angle_deg\": -30,\n      \"rx_sweep_deg\": {\n        \"start\": -90,\n        \"stop\": 90,\n        \"step\": 2\n      }\n    },\n    \"platform\": {\n      \"primary\": \"native_ubuntu_24_04_gpu\",\n      \"wsl\": \"cpu_only_unsupported_for_optix\"\n    }\n  },\n  \"stack\": {\n    \"framework\": \"Python 3.10\\u20133.12 with existing app CLI and Simulator UI (sim_server + sim_web)\",\n    \"hosting\": \"Local app execution\",\n    \"database\": \"None (filesystem outputs)\",\n    \"auth\": \"None\"\n  },\n  \"routes\": [\n    {\n      \"path\": \"/sim\",\n      \"name\": \"Simulator\",\n      \"purpose\": \"Host RIS Lab tab with Config/Run/Results sub-tabs\"\n    }\n  ],\n  \"uiNotes\": [\n    \"RIS Lab tab contains sub-tabs: Config, Run, Results\",\n    \"UI must show progress and logs and remain responsive during runs (background jobs only)\",\n    \"All UI actions must be reproducible via CLI using the same config schema\",\n    \"UI must be hosted in the Simulator surface (sim_server/sim_web), not Streamlit dashboard\"\n  ],\n  \"dataModel\": [\n    {\n      \"entity\": \"RisLabConfig\",\n      \"fields\": [\n        \"id\",\n        \"ris_geometry\",\n        \"control_synthesis\",\n        \"quantization\",\n        \"pattern_mode\",\n        \"link_mode\",\n        \"validation\",\n        \"output\"\n      ]\n    },\n    {\n      \"entity\": \"RisRun\",\n      \"fields\": [\n        \"run_id\",\n        \"started_at\",\n        \"status\",\n        \"mode\",\n        \"artifacts\",\n        \"metrics\",\n        \"errors\"\n      ]\n    },\n    {\n      \"entity\": \"ReferenceData\",\n      \"fields\": [\n        \"theta_deg\",\n        \"pattern_db\",\n        \"pattern_linear\",\n        \"meta\"\n      ]\n    }\n  ],\n  \"importFormat\": {\n    \"description\": \"Reference data with theta sweep and pattern in CSV (required), NPZ (optional), MAT (optional/stretch).\",\n    \"priority\": [\n      \"CSV\",\n      \"NPZ\",\n      \"MAT\"\n    ],\n    \"requiredFields\": {\n      \"theta_deg\": \"1D array of Rx sweep angles in degrees\",\n      \"pattern_db_or_linear\": \"Either pattern_db (dB) or pattern_linear (linear), same length as theta_deg\"\n    },\n    \"example\": {\n      \"csv\": {\n        \"columns\": [\n          \"theta_deg\",\n          \"pattern_db\"\n        ],\n        \"meta\": {\n          \"frequency_hz\": 28000000000,\n          \"tx_angle_deg\": -30,\n          \"ris_shape\": [\n            20,\n            20\n          ],\n          \"dx_m\": 0.0046,\n          \"dy_m\": 0.0046,\n          \"quantization_bits\": 1,\n          \"normalization\": \"peak_0db\"\n        }\n      }\n    }\n  },\n  \"rules\": [\n    \"Pattern mode supports normalized pattern vs Rx angle sweep and produces both linear and dB arrays\",\n    \"Default normalization is peak_0db (peak=0 dB); unit_power normalization is supported as an option\",\n    \"Link mode supports a canonical coherent sum with 1/(rt*rr) weighting and explicit phase convention; do not implement multiple competing equation variants in this PRD\",\n    \"Quantization supports continuous, 1-bit (0/pi), and 2-bit (0/pi/2/pi/3pi/2)\",\n    \"All run artifacts must be written to outputs/<run_id>/ with both config.yaml and config.json snapshots\",\n    \"No silent fallback: validation and run modes must log conventions and clearly report failures\"\n  ],\n  \"qualityGates\": [\n    \"python -m pytest\"\n  ],\n  \"stories\": [\n    {\n      \"id\": \"US-001\",\n      \"title\": \"Add ris_core math primitives and unit tests\",\n      \"status\": \"done\",\n      \"dependsOn\": [],\n      \"description\": \"As a developer, I want deterministic RIS geometry, phase synthesis, and quantization functions so validation runs are reproducible.\",\n      \"acceptanceCriteria\": [\n        \"Add a ris_core module under app/ris/ with geometry (element centers + local frame), phase synthesis (uniform, steering, focusing, custom), and quantization utilities\",\n        \"Example: for a known 2x2 RIS with dx=dy, geometry returns four element centers with expected spacing and stable ordering\",\n        \"Negative case: invalid quantization bits (e.g., 3) raises a clear validation error\",\n        \"Add unit tests covering geometry, frame construction, and quantization edge cases\",\n        \"python -m pytest passes\"\n      ],\n      \"startedAt\": \"2026-01-20T17:51:22.599335+00:00\",\n      \"completedAt\": \"2026-01-20T17:57:10.145050+00:00\",\n      \"updatedAt\": \"2026-01-20T17:57:10.145041+00:00\"\n    },\n    {\n      \"id\": \"US-002\",\n      \"title\": \"Define RIS Lab config schema and snapshot outputs\",\n      \"status\": \"done\",\n      \"dependsOn\": [\n        \"US-001\"\n      ],\n      \"description\": \"As a user, I want a YAML config for RIS Lab that resolves into canonical YAML+JSON snapshots in each run output.\",\n      \"acceptanceCriteria\": [\n        \"Add a RIS Lab config schema with defaults for geometry, control synthesis, quantization, pattern/link modes, and validation thresholds\",\n        \"Example: a minimal YAML config runs with defaults and writes outputs/<run_id>/config.yaml and outputs/<run_id>/config.json\",\n        \"Negative case: missing required fields (e.g., N/M or dx/dy) produces a clear error listing required fields\",\n        \"Config resolution is deterministic and recorded in run metadata (metrics.json or summary.json)\"\n      ],\n      \"startedAt\": \"2026-01-20T17:57:12.190815+00:00\",\n      \"completedAt\": \"2026-01-20T18:09:25.595908+00:00\",\n      \"updatedAt\": \"2026-01-20T18:09:25.595899+00:00\"\n    },\n    {\n      \"id\": \"US-003\",\n      \"title\": \"Add CLI entrypoint for RIS Lab runs and validation\",\n      \"status\": \"in_progress\",\n      \"dependsOn\": [\n        \"US-001\",\n        \"US-002\"\n      ],\n      \"description\": \"As a user, I want to run RIS Lab headlessly via python -m app ris so runs are reproducible.\",\n      \"acceptanceCriteria\": [\n        \"Add CLI commands: python -m app ris run --config <path> --mode pattern|link and python -m app ris validate --config <path> --ref <file>\",\n        \"Example: pattern run creates outputs/<run_id>/ with required artifacts (phase_map.png, pattern plots, metrics.json)\",\n        \"Negative case: invalid mode selection returns a non-zero exit and a usage hint\",\n        \"CLI logs include run_id, mode, and output directory\"\n      ],\n      \"startedAt\": \"2026-01-20T18:09:27.642152+00:00\",\n      \"completedAt\": null,\n      \"updatedAt\": \"2026-01-20T18:09:27.642160+00:00\"\n    },\n    {\n      \"id\": \"US-003A\",\n      \"title\": \"Wire RIS Lab into sim_jobs and sim_server for non-blocking UI runs\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-003\"\n      ],\n      \"description\": \"As a user, I want the Simulator UI to run RIS Lab jobs in the background using the existing job system.\",\n      \"acceptanceCriteria\": [\n        \"Add a ris_lab job type to the existing job runner (sim_jobs) with progress updates to progress.json\",\n        \"Expose an API endpoint in sim_server to start RIS Lab jobs and query status\",\n        \"Example: UI can start a RIS job and receive progress/log updates without blocking\",\n        \"Negative case: job failure surfaces an error message and preserves partial artifacts in outputs/<run_id>/\"\n      ]\n    },\n    {\n      \"id\": \"US-004\",\n      \"title\": \"Implement pattern mode artifacts and metrics\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-001\",\n        \"US-002\",\n        \"US-003\"\n      ],\n      \"description\": \"As a user, I want pattern mode to compute normalized patterns and save required artifacts and metrics.\",\n      \"acceptanceCriteria\": [\n        \"Pattern mode produces phase map, pattern arrays, and plots (Cartesian + polar) under outputs/<run_id>/\",\n        \"Artifacts include raw arrays (phase_map.npy, pattern_linear.npy, pattern_db.npy, theta_deg.npy or csv) and images\",\n        \"metrics.json includes peak angle, peak value, and a simple sidelobe metric (documented definition)\",\n        \"Negative case: mismatched theta array lengths are rejected with a clear error\"\n      ]\n    },\n    {\n      \"id\": \"US-005\",\n      \"title\": \"Add validation harness for CSV reference data\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-004\"\n      ],\n      \"description\": \"As a user, I want to validate pattern mode outputs against MATLAB CSV exports with PASS/FAIL metrics.\",\n      \"acceptanceCriteria\": [\n        \"Validation loads CSV with theta_deg + (pattern_db or pattern_linear) columns\",\n        \"Validation run creates overlay plot (reference vs sim) and error report containing RMSE and peak angle error\",\n        \"Negative case: CSV missing theta_deg or pattern column fails with a clear field list\",\n        \"PASS/FAIL result is written to metrics.json (or pass_fail.json) with threshold values used\"\n      ]\n    },\n    {\n      \"id\": \"US-006\",\n      \"title\": \"Add NPZ reference import support\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-005\"\n      ],\n      \"description\": \"As a user, I want to validate against NPZ exports when available.\",\n      \"acceptanceCriteria\": [\n        \"NPZ loader supports keys theta_deg + (pattern_db or pattern_linear)\",\n        \"NPZ validation produces the same overlay outputs as CSV validation\",\n        \"Negative case: missing keys cause a clear error listing expected keys\"\n      ]\n    },\n    {\n      \"id\": \"US-007\",\n      \"title\": \"Add MAT reference import (stretch)\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-005\"\n      ],\n      \"description\": \"As a user, I want optional MAT import support when easy to enable.\",\n      \"acceptanceCriteria\": [\n        \"If MAT import is enabled, document and add scipy as an optional dependency (extras)\",\n        \"Example: MAT file containing theta_deg + pattern_db validates and generates overlay plots\",\n        \"Negative case: when scipy is missing, CLI returns an actionable install message\"\n      ]\n    },\n    {\n      \"id\": \"US-008\",\n      \"title\": \"Add RIS Lab UI tab with Config/Run/Results\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-003A\",\n        \"US-004\",\n        \"US-005\"\n      ],\n      \"description\": \"As a user, I want a RIS Lab tab with sub-tabs for config, running, and results.\",\n      \"acceptanceCriteria\": [\n        \"RIS Lab tab appears in the existing Simulator UI with Config/Run/Results sub-tabs\",\n        \"Run tab starts a background job and updates progress/logs without blocking the UI\",\n        \"Results tab can load a completed run directory and display plots + metrics\",\n        \"Negative case: if a run fails, Results shows the error and preserves partial artifacts\"\n      ]\n    },\n    {\n      \"id\": \"US-009\",\n      \"title\": \"Add regression test fixture and validation tests\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-005\"\n      ],\n      \"description\": \"As a developer, I want a small golden fixture to keep validation metrics stable in CI.\",\n      \"acceptanceCriteria\": [\n        \"Add a small reference fixture (CSV) and a test that runs validation with known thresholds\",\n        \"Validation test asserts PASS and expected metric ranges\",\n        \"Negative case: intentionally perturbed data fails thresholds and reports FAIL\",\n        \"python -m pytest passes\"\n      ]\n    },\n    {\n      \"id\": \"US-010\",\n      \"title\": \"Document RIS Lab usage and config examples\",\n      \"status\": \"open\",\n      \"dependsOn\": [\n        \"US-003\",\n        \"US-004\",\n        \"US-005\",\n        \"US-008\"\n      ],\n      \"description\": \"As a user, I want clear docs and example configs to run RIS Lab from CLI and UI.\",\n      \"acceptanceCriteria\": [\n        \"README includes a RIS Lab section with CLI examples and required artifacts list\",\n        \"Add example configs under configs/ris/ (steer_1bit.yaml, focus_point.yaml, validate_vs_csv.yaml)\",\n        \"Docs warn that ray tracing RIS integration is out of scope and not enabled\",\n        \"Documentation describes CSV reference format and required fields\"\n      ]\n    }\n  ]\n}\n"
  }
}

thinking
**Reviewing build and test instructions**
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/AGENTS.md"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/AGENTS.md"}) success in 1ms:
{
  "content": [
    {
      "text": "# AGENTS.md — RIS_SIONNA\n**Native Ubuntu 24.04 · GPU-first (CUDA/OptiX) · Sionna RT baseline @ 28 GHz · RIS Lab (validation-first)**\n\n---\n\n## 0. HARD CONTEXT RESET (NON-NEGOTIABLE)\n\n- Primary target: **native Ubuntu 24.04**\n- GPU RT target: **CUDA + OptiX (real runtime)**\n- WSL may exist as a *CPU-only dev shell*, but **GPU OptiX on WSL is unsupported/unstable** for this repo.\n- Any GPU RT failure on native Ubuntu is treated as **misconfiguration**, not “platform limitation”.\n\nThis repo must never silently “looks fine” while running CPU/LLVM when a GPU is available.\nIf we fall back, we must say so loudly and explain why.\n\n---\n\n## 1. SYSTEM ENVIRONMENT (AUTHORITATIVE)\n\n**Baseline assumptions for “GPU-first” work:**\n- OS: Ubuntu 24.04 (native install)\n- GPU: NVIDIA RTX-class (project dev box is 4070 Ti ~12 GB VRAM)\n- NVIDIA driver: proprietary, modern (>= 570 recommended)\n- OptiX runtime: present and real (not a stub)\n- Python: 3.10–3.12\n- Sionna pinned in `pyproject.toml` (currently `sionna==1.2.1`)\n- NumPy pinned to stay compatible with Sionna (`numpy<2.0`)\n\nRT stack:\n- Sionna RT (via Sionna)\n- Mitsuba 3\n- Dr.Jit\n- CUDA/OptiX backend\n\n**Hard checks (required before claiming “GPU works”):**\n- `nvidia-smi` works\n- `python -m app diagnose` reports CUDA variant + OptiX symbols OK\n- A GPU smoke test completes and logs backend + timing\n- No silent backend fallback\n\n---\n\n## 2. REPO CONTEXT\n\n- Repo path: `~/Documents/Github/RIS_SIONNA`\n- Git remote: `https://github.com/saladfingers379/RIS_SIONNA.git`\n- Core interfaces:\n  - CLI: `python -m app …`\n  - Config: YAML under `configs/`\n  - Outputs: `outputs/<run_id>/` with `config.yaml`, `run.log`, `progress.json`, `summary.json`, `data/`, `plots/`, `viewer/`\n  - Simulator UI: `python -m app sim` (stdlib HTTP server + background jobs)\n\nRegression landmines:\n- Coverage/heatmap alignment was previously fixed — **DO NOT REGRESS**.\n\nQuality gates:\n- **`python -m pytest`** must pass.\n\n---\n\n## 3. PRIMARY OBJECTIVES (ORDERED)\n\n### Track A — Sionna RT baseline (GPU-first, stable)\n1. Prove GPU usage for RT (CUDA/OptiX, not CPU/LLVM)\n2. Provide repeatable GPU profiles (low/medium/high) without breaking CPU-only mode\n3. Preserve correctness + official Sionna RT APIs\n4. Maintain UX: progress, logs, responsive UI, clean outputs\n\n### Track B — RIS Lab (validation-first, math-first)\n5. Build a **RIS Lab** that lets us design/tune RIS behavior and validate against:\n   - MATLAB reference exports (CSV required; NPZ optional; MAT stretch)\n   - paper-style methodology (Tx fixed, Rx sweep; normalized patterns; optional link-mode)\n6. Produce deterministic artifacts and regression tests so parity doesn’t rot\n7. Keep a clean promotion path to later integrate validated RIS into the main pipeline\n\n**Important boundary:** RIS Lab is *not* RT RIS integration.\nIt is a controlled, math-driven “RIS compositor / lab bench” that runs on CPU.\n\n---\n\n## 4. NON-NEGOTIABLE RULES\n\n- Accuracy > speed\n- Use **official Sionna RT APIs** (no undocumented hacks)\n- GPU usage must be **explicitly proven** (diagnose + smoke)\n- No silent fallback: if CPU/LLVM is used, print a single loud verdict + fixes\n- Outputs must be reproducible and saved under `outputs/<run_id>/`\n- Keep configuration-driven behavior (no magic constants in code)\n- Never regress heatmap alignment\n\n---\n\n## 5. PHASED WORK PLAN\n\n### Phase 0 — Native Linux GPU validation (FIRST, ALWAYS)\nBefore changing sim logic:\n- Verify:\n  - `nvidia-smi` OK\n  - CUDA visible in Python\n  - Mitsuba CUDA variants visible\n  - OptiX symbols present\n- Confirm:\n  - no WSL/Windows shims are in play\n- Document known-good setup in:\n  - `README.md`\n  - `docs/TROUBLESHOOTING.md`\n\nDefinition of done:\n- `python -m app diagnose` ends with exactly one verdict:\n  - ✅ `RT backend is CUDA/OptiX`\n  - ⚠️ `RT backend is CPU/LLVM` (with actionable fixes)\n\n---\n\n### Phase A — Repo audit (fast)\nUse filesystem tooling to identify:\n- CLI entrypoints + command routing\n- where Sionna RT is initialized\n- where Mitsuba/Dr.Jit variants are selected\n- scene build/load path\n- radio-map sampling path\n- job runner / UI polling path (`sim_jobs.py`, `sim_server.py`, `sim_web/`)\n\nDeliverable:\n- short summary of backend selection logic + insertion points for diagnostics + RIS Lab job type\n\n---\n\n### Phase B — Bulletproof GPU diagnostics\nHarden `python -m app diagnose`:\nMust print:\n- OS / kernel, Python version\n- NVIDIA driver (from `nvidia-smi` if available)\n- Sionna version + key deps\n- available Mitsuba variants\n- selected variant\n- OptiX availability (symbols/runtime)\n- backend actually used for a tiny RT call\n\nMust end with a single verdict line (see Phase 0).\n\nNo silent fallback.\n\n---\n\n### Phase C — GPU smoke test\nAdd/keep a minimal RT workload that:\n- forces selection of GPU backend when available\n- runs a tiny path/radiomap task\n- reports backend + timing\n- writes to `outputs/<run_id>/summary.json`\n\nPurpose: proof, not benchmarking.\n\n---\n\n### Phase D — High-compute GPU profiles\nMaintain or add:\n- `configs/high.yaml` (GPU high)\n- plus optional `gpu_low.yaml`, `gpu_medium.yaml`\n\nRequirements:\n- stress GPU meaningfully (grid size, batching)\n- show progress + ETA\n- record wall time\n- write `summary.json` including backend, driver, variant, config snapshot/hash\n\nCPU-only must still run via preview/default configs.\n\n---\n\n## 6. RIS LAB PLAN (VALIDATION-FIRST)\n\n### Phase R1 — RIS core (math primitives)\nCreate `app/ris/` modules:\n- geometry (element centers + frames)\n- control synthesis (uniform / steer / focus / custom phase)\n- quantization (none / 1-bit / 2-bit)\n- pattern-mode runner (normalized pattern vs Rx sweep)\n- artifacts writer (arrays + plots under outputs/<run_id>/)\n\nDefinition of done:\n- CLI can run pattern-mode and produce required artifacts.\n\n### Phase R2 — Validation harness\nImplement reference import:\n- CSV required\n- NPZ optional\n- MAT stretch (scipy optional dependency)\n\nMetrics:\n- RMSE (dB), peak angle error (deg), optional peak dB error\n- PASS/FAIL summary written into run metrics\n\nDefinition of done:\n- `python -m app ris validate ...` produces overlay plots + errors + PASS/FAIL.\n\n### Phase R3 — UI integration (simulator tab)\nAdd a “RIS Lab” tab to simulator UI with sub-tabs:\n- Config / Run / Results\n- start runs via background jobs\n- show progress/logs, render plots from outputs directory\n- keep UI responsive\n\nDefinition of done:\n- UI triggers RIS Lab job without blocking and can browse prior runs.\n\n### Phase R4 — Promotion path (NOT RT integration)\nAdd a feature-flagged way to reuse validated RIS Lab configs in the main sim **as a compositor**.\n(Still no Sionna RT RIS integration.)\n\n---\n\n## 7. EXPLICIT EXCLUSIONS (CURRENT SCOPE)\n\n- No Sionna RT RIS integration yet (no ray-traced RIS scattering)\n- No optimization / auto-tuning loops\n- No GIS ingestion\n- No CUDA hacks or `LD_PRELOAD`\n- No pretending CPU fallback is acceptable for GPU profiles (fallback must be explicit + actionable)\n\n---\n\n## 8. START HERE (ORDERED)\n\n1. Confirm Phase 0 on native Ubuntu (diagnose + smoke must be clean)\n2. Audit backend selection + job runner insertion points (Phase A)\n3. Build RIS Lab Phase R1 (pattern-mode + artifacts + tests)\n4. Add validation (Phase R2)\n5. Add simulator UI tab (Phase R3)\n6. Only then consider compositor promotion (Phase R4)\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "# AGENTS.md — RIS_SIONNA\n**Native Ubuntu 24.04 · GPU-first (CUDA/OptiX) · Sionna RT baseline @ 28 GHz · RIS Lab (validation-first)**\n\n---\n\n## 0. HARD CONTEXT RESET (NON-NEGOTIABLE)\n\n- Primary target: **native Ubuntu 24.04**\n- GPU RT target: **CUDA + OptiX (real runtime)**\n- WSL may exist as a *CPU-only dev shell*, but **GPU OptiX on WSL is unsupported/unstable** for this repo.\n- Any GPU RT failure on native Ubuntu is treated as **misconfiguration**, not “platform limitation”.\n\nThis repo must never silently “looks fine” while running CPU/LLVM when a GPU is available.\nIf we fall back, we must say so loudly and explain why.\n\n---\n\n## 1. SYSTEM ENVIRONMENT (AUTHORITATIVE)\n\n**Baseline assumptions for “GPU-first” work:**\n- OS: Ubuntu 24.04 (native install)\n- GPU: NVIDIA RTX-class (project dev box is 4070 Ti ~12 GB VRAM)\n- NVIDIA driver: proprietary, modern (>= 570 recommended)\n- OptiX runtime: present and real (not a stub)\n- Python: 3.10–3.12\n- Sionna pinned in `pyproject.toml` (currently `sionna==1.2.1`)\n- NumPy pinned to stay compatible with Sionna (`numpy<2.0`)\n\nRT stack:\n- Sionna RT (via Sionna)\n- Mitsuba 3\n- Dr.Jit\n- CUDA/OptiX backend\n\n**Hard checks (required before claiming “GPU works”):**\n- `nvidia-smi` works\n- `python -m app diagnose` reports CUDA variant + OptiX symbols OK\n- A GPU smoke test completes and logs backend + timing\n- No silent backend fallback\n\n---\n\n## 2. REPO CONTEXT\n\n- Repo path: `~/Documents/Github/RIS_SIONNA`\n- Git remote: `https://github.com/saladfingers379/RIS_SIONNA.git`\n- Core interfaces:\n  - CLI: `python -m app …`\n  - Config: YAML under `configs/`\n  - Outputs: `outputs/<run_id>/` with `config.yaml`, `run.log`, `progress.json`, `summary.json`, `data/`, `plots/`, `viewer/`\n  - Simulator UI: `python -m app sim` (stdlib HTTP server + background jobs)\n\nRegression landmines:\n- Coverage/heatmap alignment was previously fixed — **DO NOT REGRESS**.\n\nQuality gates:\n- **`python -m pytest`** must pass.\n\n---\n\n## 3. PRIMARY OBJECTIVES (ORDERED)\n\n### Track A — Sionna RT baseline (GPU-first, stable)\n1. Prove GPU usage for RT (CUDA/OptiX, not CPU/LLVM)\n2. Provide repeatable GPU profiles (low/medium/high) without breaking CPU-only mode\n3. Preserve correctness + official Sionna RT APIs\n4. Maintain UX: progress, logs, responsive UI, clean outputs\n\n### Track B — RIS Lab (validation-first, math-first)\n5. Build a **RIS Lab** that lets us design/tune RIS behavior and validate against:\n   - MATLAB reference exports (CSV required; NPZ optional; MAT stretch)\n   - paper-style methodology (Tx fixed, Rx sweep; normalized patterns; optional link-mode)\n6. Produce deterministic artifacts and regression tests so parity doesn’t rot\n7. Keep a clean promotion path to later integrate validated RIS into the main pipeline\n\n**Important boundary:** RIS Lab is *not* RT RIS integration.\nIt is a controlled, math-driven “RIS compositor / lab bench” that runs on CPU.\n\n---\n\n## 4. NON-NEGOTIABLE RULES\n\n- Accuracy > speed\n- Use **official Sionna RT APIs** (no undocumented hacks)\n- GPU usage must be **explicitly proven** (diagnose + smoke)\n- No silent fallback: if CPU/LLVM is used, print a single loud verdict + fixes\n- Outputs must be reproducible and saved under `outputs/<run_id>/`\n- Keep configuration-driven behavior (no magic constants in code)\n- Never regress heatmap alignment\n\n---\n\n## 5. PHASED WORK PLAN\n\n### Phase 0 — Native Linux GPU validation (FIRST, ALWAYS)\nBefore changing sim logic:\n- Verify:\n  - `nvidia-smi` OK\n  - CUDA visible in Python\n  - Mitsuba CUDA variants visible\n  - OptiX symbols present\n- Confirm:\n  - no WSL/Windows shims are in play\n- Document known-good setup in:\n  - `README.md`\n  - `docs/TROUBLESHOOTING.md`\n\nDefinition of done:\n- `python -m app diagnose` ends with exactly one verdict:\n  - ✅ `RT backend is CUDA/OptiX`\n  - ⚠️ `RT backend is CPU/LLVM` (with actionable fixes)\n\n---\n\n### Phase A — Repo audit (fast)\nUse filesystem tooling to identify:\n- CLI entrypoints + command routing\n- where Sionna RT is initialized\n- where Mitsuba/Dr.Jit variants are selected\n- scene build/load path\n- radio-map sampling path\n- job runner / UI polling path (`sim_jobs.py`, `sim_server.py`, `sim_web/`)\n\nDeliverable:\n- short summary of backend selection logic + insertion points for diagnostics + RIS Lab job type\n\n---\n\n### Phase B — Bulletproof GPU diagnostics\nHarden `python -m app diagnose`:\nMust print:\n- OS / kernel, Python version\n- NVIDIA driver (from `nvidia-smi` if available)\n- Sionna version + key deps\n- available Mitsuba variants\n- selected variant\n- OptiX availability (symbols/runtime)\n- backend actually used for a tiny RT call\n\nMust end with a single verdict line (see Phase 0).\n\nNo silent fallback.\n\n---\n\n### Phase C — GPU smoke test\nAdd/keep a minimal RT workload that:\n- forces selection of GPU backend when available\n- runs a tiny path/radiomap task\n- reports backend + timing\n- writes to `outputs/<run_id>/summary.json`\n\nPurpose: proof, not benchmarking.\n\n---\n\n### Phase D — High-compute GPU profiles\nMaintain or add:\n- `configs/high.yaml` (GPU high)\n- plus optional `gpu_low.yaml`, `gpu_medium.yaml`\n\nRequirements:\n- stress GPU meaningfully (grid size, batching)\n- show progress + ETA\n- record wall time\n- write `summary.json` including backend, driver, variant, config snapshot/hash\n\nCPU-only must still run via preview/default configs.\n\n---\n\n## 6. RIS LAB PLAN (VALIDATION-FIRST)\n\n### Phase R1 — RIS core (math primitives)\nCreate `app/ris/` modules:\n- geometry (element centers + frames)\n- control synthesis (uniform / steer / focus / custom phase)\n- quantization (none / 1-bit / 2-bit)\n- pattern-mode runner (normalized pattern vs Rx sweep)\n- artifacts writer (arrays + plots under outputs/<run_id>/)\n\nDefinition of done:\n- CLI can run pattern-mode and produce required artifacts.\n\n### Phase R2 — Validation harness\nImplement reference import:\n- CSV required\n- NPZ optional\n- MAT stretch (scipy optional dependency)\n\nMetrics:\n- RMSE (dB), peak angle error (deg), optional peak dB error\n- PASS/FAIL summary written into run metrics\n\nDefinition of done:\n- `python -m app ris validate ...` produces overlay plots + errors + PASS/FAIL.\n\n### Phase R3 — UI integration (simulator tab)\nAdd a “RIS Lab” tab to simulator UI with sub-tabs:\n- Config / Run / Results\n- start runs via background jobs\n- show progress/logs, render plots from outputs directory\n- keep UI responsive\n\nDefinition of done:\n- UI triggers RIS Lab job without blocking and can browse prior runs.\n\n### Phase R4 — Promotion path (NOT RT integration)\nAdd a feature-flagged way to reuse validated RIS Lab configs in the main sim **as a compositor**.\n(Still no Sionna RT RIS integration.)\n\n---\n\n## 7. EXPLICIT EXCLUSIONS (CURRENT SCOPE)\n\n- No Sionna RT RIS integration yet (no ray-traced RIS scattering)\n- No optimization / auto-tuning loops\n- No GIS ingestion\n- No CUDA hacks or `LD_PRELOAD`\n- No pretending CPU fallback is acceptable for GPU profiles (fallback must be explicit + actionable)\n\n---\n\n## 8. START HERE (ORDERED)\n\n1. Confirm Phase 0 on native Ubuntu (diagnose + smoke must be clean)\n2. Audit backend selection + job runner insertion points (Phase A)\n3. Build RIS Lab Phase R1 (pattern-mode + artifacts + tests)\n4. Add validation (Phase R2)\n5. Add simulator UI tab (Phase R3)\n6. Only then consider compositor promotion (Phase R4)\n"
  }
}

thinking
**Preparing to audit CLI and add logging**

Now focusing on auditing necessary files for story US-003 and enhancing major actions with ralph log commands; next step is exploring the CLI entrypoint using rg.
exec
/usr/bin/zsh -lc 'rg "def main|argparse|click|typer|python -m app" -n app' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 6ms:
app/dashboard_app.py:55:    regen_clicked = st.button("Regenerate viewer now")
app/dashboard_app.py:73:if regen_clicked:
app/utils/system.py:506:            "Re-run `python -m app diagnose` after fixing CUDA availability.",
app/cli.py:1:import argparse
app/cli.py:27:def _parse_args() -> argparse.Namespace:
app/cli.py:28:    parser = argparse.ArgumentParser(prog="python -m app", description="RIS_SIONNA CLI")
app/cli.py:55:def main() -> None:
app/sim_web/app.js:960:    row.addEventListener("click", () => highlightPath(p));
app/sim_web/app.js:1190:  ui.refreshRuns.addEventListener("click", fetchRuns);
app/sim_web/app.js:1202:  ui.applyMarkers.addEventListener("click", () => {
app/sim_web/app.js:1211:  ui.runSim.addEventListener("click", () => submitJob());
app/sim_web/app.js:1212:  ui.topDown.addEventListener("click", () => {
app/sim_web/app.js:1216:  ui.snapshot.addEventListener("click", () => {
app/sim_web/app.js:1220:    link.click();
app/sim_web/app.js:1276:  ui.randomizeMarkers.addEventListener("click", randomizeMarkers);

thinking
**Inspecting CLI implementation**
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/cli.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/cli.py"}) success in 1ms:
{
  "content": [
    {
      "text": "import argparse\nimport logging\nimport os\nimport socket\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom .io import find_latest_output_dir\nfrom .plots import plot_radio_map_from_npz\nfrom .simulate import run_simulation\nfrom .utils.logging import setup_logging\nfrom .utils.system import print_diagnose_info\n\nlogger = logging.getLogger(__name__)\n\ndef _pick_dashboard_port(preferred: int = 8501) -> int:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        try:\n            sock.bind((\"127.0.0.1\", preferred))\n            return preferred\n        except OSError:\n            sock.bind((\"127.0.0.1\", 0))\n            return sock.getsockname()[1]\n\ndef _parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(prog=\"python -m app\", description=\"RIS_SIONNA CLI\")\n    subparsers = parser.add_subparsers(dest=\"command\", required=True)\n\n    run_p = subparsers.add_parser(\"run\", help=\"Run a Sionna RT simulation\")\n    run_p.add_argument(\"--config\", required=True, help=\"Path to YAML config\")\n\n    plot_p = subparsers.add_parser(\"plot\", help=\"Plot from saved outputs\")\n    plot_group = plot_p.add_mutually_exclusive_group(required=True)\n    plot_group.add_argument(\"--latest\", action=\"store_true\", help=\"Use latest output dir\")\n    plot_group.add_argument(\"--output-dir\", help=\"Path to an outputs/<timestamp> directory\")\n    plot_p.add_argument(\n        \"--metric\",\n        default=\"path_gain_db\",\n        choices=[\"path_gain_db\", \"rx_power_dbm\", \"path_loss_db\"],\n        help=\"Which metric to plot\",\n    )\n\n    subparsers.add_parser(\"diagnose\", help=\"Print environment diagnostics\")\n    subparsers.add_parser(\"dashboard\", help=\"Launch the visualization dashboard\")\n    sim_p = subparsers.add_parser(\"sim\", help=\"Launch the Omniverse-lite simulator\")\n    sim_p.add_argument(\"--host\", default=\"127.0.0.1\", help=\"Host to bind the simulator\")\n    sim_p.add_argument(\"--port\", type=int, default=8765, help=\"Port for the simulator UI\")\n    sim_p.add_argument(\"--no-browser\", action=\"store_true\", help=\"Do not open the browser automatically\")\n\n    return parser.parse_args()\n\n\ndef main() -> None:\n    setup_logging()\n    args = _parse_args()\n\n    if args.command == \"run\":\n        output_dir = run_simulation(args.config)\n        logger.info(\"Outputs saved to %s\", output_dir)\n        return\n\n    if args.command == \"plot\":\n        if args.latest:\n            output_dir = find_latest_output_dir(\"outputs\")\n            if output_dir is None:\n                raise SystemExit(\"No outputs found under ./outputs\")\n        else:\n            output_dir = Path(args.output_dir)\n\n        npz_path = output_dir / \"data\" / \"radio_map.npz\"\n        if not npz_path.exists():\n            raise SystemExit(f\"radio_map.npz not found in {output_dir}\")\n\n        plots_dir = output_dir / \"plots\"\n        plots_dir.mkdir(parents=True, exist_ok=True)\n        metric_map = {\n            \"path_gain_db\": (\"path_gain_db\", \"Path gain [dB]\", \"radio_map_path_gain_db\"),\n            \"rx_power_dbm\": (\"rx_power_dbm\", \"Rx power [dBm]\", \"radio_map_rx_power_dbm\"),\n            \"path_loss_db\": (\"path_loss_db\", \"Path loss [dB]\", \"radio_map_path_loss_db\"),\n        }[args.metric]\n        plot_radio_map_from_npz(npz_path, plots_dir, *metric_map)\n        logger.info(\"Plots saved to %s\", output_dir / \"plots\")\n        return\n\n    if args.command == \"diagnose\":\n        print_diagnose_info()\n        return\n\n    if args.command == \"dashboard\":\n        try:\n            import streamlit  # noqa: F401\n        except Exception:\n            raise SystemExit(\"Streamlit not installed. Install with: pip install .[dashboard]\")\n\n        port = _pick_dashboard_port(8501)\n        logger.info(\"Starting dashboard at http://127.0.0.1:%s (press Ctrl+C to stop)\", port)\n        env = dict(**dict(os.environ))\n        env.setdefault(\"STREAMLIT_BROWSER_GATHER_USAGE_STATS\", \"false\")\n        subprocess.run(\n            [\n                sys.executable,\n                \"-m\",\n                \"streamlit\",\n                \"run\",\n                \"app/dashboard_app.py\",\n                \"--server.headless\",\n                \"true\",\n                \"--server.fileWatcherType\",\n                \"none\",\n                \"--server.address\",\n                \"127.0.0.1\",\n                \"--server.port\",\n                str(port),\n                \"--browser.gatherUsageStats\",\n                \"false\",\n            ],\n            check=True,\n            env=env,\n        )\n        return\n\n    if args.command == \"sim\":\n        from .sim_server import serve_simulator\n        if not args.no_browser:\n            import webbrowser\n            webbrowser.open(f\"http://{args.host}:{args.port}\")\n        serve_simulator(host=args.host, port=int(args.port))\n        return\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "import argparse\nimport logging\nimport os\nimport socket\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom .io import find_latest_output_dir\nfrom .plots import plot_radio_map_from_npz\nfrom .simulate import run_simulation\nfrom .utils.logging import setup_logging\nfrom .utils.system import print_diagnose_info\n\nlogger = logging.getLogger(__name__)\n\ndef _pick_dashboard_port(preferred: int = 8501) -> int:\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        try:\n            sock.bind((\"127.0.0.1\", preferred))\n            return preferred\n        except OSError:\n            sock.bind((\"127.0.0.1\", 0))\n            return sock.getsockname()[1]\n\ndef _parse_args() -> argparse.Namespace:\n    parser = argparse.ArgumentParser(prog=\"python -m app\", description=\"RIS_SIONNA CLI\")\n    subparsers = parser.add_subparsers(dest=\"command\", required=True)\n\n    run_p = subparsers.add_parser(\"run\", help=\"Run a Sionna RT simulation\")\n    run_p.add_argument(\"--config\", required=True, help=\"Path to YAML config\")\n\n    plot_p = subparsers.add_parser(\"plot\", help=\"Plot from saved outputs\")\n    plot_group = plot_p.add_mutually_exclusive_group(required=True)\n    plot_group.add_argument(\"--latest\", action=\"store_true\", help=\"Use latest output dir\")\n    plot_group.add_argument(\"--output-dir\", help=\"Path to an outputs/<timestamp> directory\")\n    plot_p.add_argument(\n        \"--metric\",\n        default=\"path_gain_db\",\n        choices=[\"path_gain_db\", \"rx_power_dbm\", \"path_loss_db\"],\n        help=\"Which metric to plot\",\n    )\n\n    subparsers.add_parser(\"diagnose\", help=\"Print environment diagnostics\")\n    subparsers.add_parser(\"dashboard\", help=\"Launch the visualization dashboard\")\n    sim_p = subparsers.add_parser(\"sim\", help=\"Launch the Omniverse-lite simulator\")\n    sim_p.add_argument(\"--host\", default=\"127.0.0.1\", help=\"Host to bind the simulator\")\n    sim_p.add_argument(\"--port\", type=int, default=8765, help=\"Port for the simulator UI\")\n    sim_p.add_argument(\"--no-browser\", action=\"store_true\", help=\"Do not open the browser automatically\")\n\n    return parser.parse_args()\n\n\ndef main() -> None:\n    setup_logging()\n    args = _parse_args()\n\n    if args.command == \"run\":\n        output_dir = run_simulation(args.config)\n        logger.info(\"Outputs saved to %s\", output_dir)\n        return\n\n    if args.command == \"plot\":\n        if args.latest:\n            output_dir = find_latest_output_dir(\"outputs\")\n            if output_dir is None:\n                raise SystemExit(\"No outputs found under ./outputs\")\n        else:\n            output_dir = Path(args.output_dir)\n\n        npz_path = output_dir / \"data\" / \"radio_map.npz\"\n        if not npz_path.exists():\n            raise SystemExit(f\"radio_map.npz not found in {output_dir}\")\n\n        plots_dir = output_dir / \"plots\"\n        plots_dir.mkdir(parents=True, exist_ok=True)\n        metric_map = {\n            \"path_gain_db\": (\"path_gain_db\", \"Path gain [dB]\", \"radio_map_path_gain_db\"),\n            \"rx_power_dbm\": (\"rx_power_dbm\", \"Rx power [dBm]\", \"radio_map_rx_power_dbm\"),\n            \"path_loss_db\": (\"path_loss_db\", \"Path loss [dB]\", \"radio_map_path_loss_db\"),\n        }[args.metric]\n        plot_radio_map_from_npz(npz_path, plots_dir, *metric_map)\n        logger.info(\"Plots saved to %s\", output_dir / \"plots\")\n        return\n\n    if args.command == \"diagnose\":\n        print_diagnose_info()\n        return\n\n    if args.command == \"dashboard\":\n        try:\n            import streamlit  # noqa: F401\n        except Exception:\n            raise SystemExit(\"Streamlit not installed. Install with: pip install .[dashboard]\")\n\n        port = _pick_dashboard_port(8501)\n        logger.info(\"Starting dashboard at http://127.0.0.1:%s (press Ctrl+C to stop)\", port)\n        env = dict(**dict(os.environ))\n        env.setdefault(\"STREAMLIT_BROWSER_GATHER_USAGE_STATS\", \"false\")\n        subprocess.run(\n            [\n                sys.executable,\n                \"-m\",\n                \"streamlit\",\n                \"run\",\n                \"app/dashboard_app.py\",\n                \"--server.headless\",\n                \"true\",\n                \"--server.fileWatcherType\",\n                \"none\",\n                \"--server.address\",\n                \"127.0.0.1\",\n                \"--server.port\",\n                str(port),\n                \"--browser.gatherUsageStats\",\n                \"false\",\n            ],\n            check=True,\n            env=env,\n        )\n        return\n\n    if args.command == \"sim\":\n        from .sim_server import serve_simulator\n        if not args.no_browser:\n            import webbrowser\n            webbrowser.open(f\"http://{args.host}:{args.port}\")\n        serve_simulator(host=args.host, port=int(args.port))\n        return\n\n\nif __name__ == \"__main__\":\n    main()\n"
  }
}

thinking
**Exploring RIS modules**

I'm looking for RIS-related modules in US-001 and US-002 and listing contents under app/ris to prepare adding the ris subcommand with run and validate.
exec
/usr/bin/zsh -lc 'ls -la app/ris' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 3ms:
total 32
drwxrwxr-x 3 josh josh 4096 Jan 20 18:01 .
drwxrwxr-x 6 josh josh 4096 Jan 19 20:19 ..
-rw-rw-r-- 1 josh josh  585 Jan 20 18:01 __init__.py
drwxrwxr-x 2 josh josh 4096 Jan 20 18:03 __pycache__
-rw-rw-r-- 1 josh josh 6059 Jan 20 18:03 ris_config.py
-rw-rw-r-- 1 josh josh 4798 Jan 20 17:54 ris_core.py

thinking
**Planning to read configuration files**

I'm preparing to access the ris_config and related files to gather necessary configuration details.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/ris/__init__.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/ris/__init__.py"}) success in 1ms:
{
  "content": [
    {
      "text": "\"\"\"RIS core math primitives and helpers.\"\"\"\n\nfrom .ris_config import (  # noqa: F401\n    RIS_LAB_SCHEMA_VERSION,\n    compute_ris_lab_config_hash,\n    load_ris_lab_config,\n    resolve_and_snapshot_ris_lab_config,\n    resolve_ris_lab_config,\n    snapshot_ris_lab_config,\n)\nfrom .ris_core import (  # noqa: F401\n    RisFrame,\n    RisGeometry,\n    compute_element_centers,\n    compute_local_frame,\n    degrees_to_radians,\n    quantize_phase,\n    radians_to_degrees,\n    synthesize_custom_phase,\n    synthesize_focusing_phase,\n    synthesize_steering_phase,\n    synthesize_uniform_phase,\n)\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "\"\"\"RIS core math primitives and helpers.\"\"\"\n\nfrom .ris_config import (  # noqa: F401\n    RIS_LAB_SCHEMA_VERSION,\n    compute_ris_lab_config_hash,\n    load_ris_lab_config,\n    resolve_and_snapshot_ris_lab_config,\n    resolve_ris_lab_config,\n    snapshot_ris_lab_config,\n)\nfrom .ris_core import (  # noqa: F401\n    RisFrame,\n    RisGeometry,\n    compute_element_centers,\n    compute_local_frame,\n    degrees_to_radians,\n    quantize_phase,\n    radians_to_degrees,\n    synthesize_custom_phase,\n    synthesize_focusing_phase,\n    synthesize_steering_phase,\n    synthesize_uniform_phase,\n)\n"
  }
}
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_config.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_config.py"}) success in 1ms:
{
  "content": [
    {
      "text": "\"\"\"RIS Lab configuration schema and snapshot helpers.\"\"\"\n\nfrom __future__ import annotations\n\nimport copy\nimport hashlib\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport yaml\n\nfrom app.io import create_output_dir, save_json, save_yaml\n\nRIS_LAB_SCHEMA_VERSION = 1\n\nDEFAULT_RIS_LAB_CONFIG: Dict[str, Any] = {\n    \"schema_version\": RIS_LAB_SCHEMA_VERSION,\n    \"geometry\": {\n        \"nx\": None,\n        \"ny\": None,\n        \"dx\": None,\n        \"dy\": None,\n        \"origin\": [0.0, 0.0, 0.0],\n        \"normal\": [0.0, 0.0, 1.0],\n        \"x_axis_hint\": [1.0, 0.0, 0.0],\n    },\n    \"control\": {\n        \"mode\": \"uniform\",\n        \"params\": {\"phase_rad\": 0.0},\n    },\n    \"quantization\": {\n        \"bits\": 0,\n    },\n    \"pattern_mode\": {\n        \"normalization\": \"peak_0db\",\n        \"rx_sweep_deg\": {\"start\": -90.0, \"stop\": 90.0, \"step\": 2.0},\n    },\n    \"link_mode\": {\n        \"weighting\": \"inverse_distance\",\n        \"enabled\": False,\n    },\n    \"validation\": {\n        \"normalization\": \"peak_0db\",\n        \"rmse_db_max\": 2.0,\n        \"peak_angle_err_deg_max\": 2.0,\n        \"peak_db_err_max\": 1.5,\n    },\n    \"experiment\": {\n        \"frequency_hz\": 28_000_000_000,\n        \"tx_incident_angle_deg\": -30.0,\n    },\n    \"output\": {\n        \"base_dir\": \"outputs\",\n        \"run_id\": None,\n    },\n}\n\n_ALIAS_FIELDS = {\n    (\"geometry\", \"nx\"): [(\"geometry\", \"n\")],\n    (\"geometry\", \"ny\"): [(\"geometry\", \"m\")],\n    (\"geometry\", \"dx\"): [(\"geometry\", \"dx_m\")],\n    (\"geometry\", \"dy\"): [(\"geometry\", \"dy_m\")],\n}\n\n\ndef _deep_merge(base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]:\n    for key, value in override.items():\n        if isinstance(value, dict) and isinstance(base.get(key), dict):\n            base[key] = _deep_merge(base[key], value)\n        else:\n            base[key] = value\n    return base\n\n\ndef _apply_aliases(config: Dict[str, Any]) -> Dict[str, Any]:\n    updated = copy.deepcopy(config)\n    for (section, key), aliases in _ALIAS_FIELDS.items():\n        section_data = updated.get(section)\n        if not isinstance(section_data, dict):\n            continue\n        if key in section_data:\n            continue\n        for alias_section, alias_key in aliases:\n            alias_data = updated.get(alias_section)\n            if isinstance(alias_data, dict) and alias_key in alias_data:\n                section_data[key] = alias_data[alias_key]\n                break\n        updated[section] = section_data\n    return updated\n\n\ndef _missing_required_fields(geometry: Dict[str, Any]) -> list[str]:\n    required = (\"nx\", \"ny\", \"dx\", \"dy\")\n    missing = []\n    for key in required:\n        value = geometry.get(key)\n        if value is None:\n            missing.append(f\"geometry.{key}\")\n    return missing\n\n\ndef _canonicalize_config(config: Dict[str, Any]) -> Dict[str, Any]:\n    ordered_keys = [\n        \"schema_version\",\n        \"geometry\",\n        \"control\",\n        \"quantization\",\n        \"pattern_mode\",\n        \"link_mode\",\n        \"validation\",\n        \"experiment\",\n        \"output\",\n    ]\n    ordered: Dict[str, Any] = {}\n    for key in ordered_keys:\n        if key in config:\n            ordered[key] = config[key]\n    extras = {k: v for k, v in config.items() if k not in ordered_keys}\n    for key in sorted(extras):\n        ordered[key] = extras[key]\n    return ordered\n\n\ndef resolve_ris_lab_config(raw_config: Dict[str, Any]) -> Dict[str, Any]:\n    if not isinstance(raw_config, dict):\n        raise ValueError(\"RIS Lab config must be a YAML mapping\")\n\n    normalized = _apply_aliases(raw_config)\n    resolved = _deep_merge(copy.deepcopy(DEFAULT_RIS_LAB_CONFIG), normalized)\n\n    geometry = resolved.get(\"geometry\")\n    if not isinstance(geometry, dict):\n        raise ValueError(\"RIS Lab config geometry must be a mapping\")\n\n    missing = _missing_required_fields(geometry)\n    if missing:\n        raise ValueError(\n            \"RIS Lab config missing required fields: \" + \", \".join(missing)\n        )\n\n    return _canonicalize_config(resolved)\n\n\ndef load_ris_lab_config(path: str | Path) -> Dict[str, Any]:\n    config_path = Path(path)\n    if not config_path.exists():\n        raise FileNotFoundError(f\"RIS Lab config not found: {config_path}\")\n    with config_path.open(\"r\", encoding=\"utf-8\") as handle:\n        data = yaml.safe_load(handle)\n    return resolve_ris_lab_config(data)\n\n\ndef compute_ris_lab_config_hash(config: Dict[str, Any]) -> str:\n    payload = json.dumps(config, sort_keys=True).encode(\"utf-8\")\n    return hashlib.sha256(payload).hexdigest()\n\n\ndef _ensure_output_dir(output_dir: Path) -> Path:\n    output_dir.mkdir(parents=True, exist_ok=True)\n    (output_dir / \"plots\").mkdir(parents=True, exist_ok=True)\n    (output_dir / \"data\").mkdir(parents=True, exist_ok=True)\n    return output_dir\n\n\ndef snapshot_ris_lab_config(output_dir: Path, config: Dict[str, Any]) -> Dict[str, Any]:\n    output_dir = _ensure_output_dir(output_dir)\n    yaml_path = output_dir / \"config.yaml\"\n    json_path = output_dir / \"config.json\"\n    save_yaml(yaml_path, config)\n    save_json(json_path, config)\n\n    config_hash = compute_ris_lab_config_hash(config)\n    summary = {\n        \"schema_version\": config.get(\"schema_version\", RIS_LAB_SCHEMA_VERSION),\n        \"config\": {\n            \"hash_sha256\": config_hash,\n            \"path_yaml\": str(yaml_path),\n            \"path_json\": str(json_path),\n        },\n    }\n    save_json(output_dir / \"summary.json\", summary)\n    return summary\n\n\ndef resolve_and_snapshot_ris_lab_config(\n    config_path: str | Path,\n    output_dir: Optional[str | Path] = None,\n) -> tuple[Dict[str, Any], Path, Dict[str, Any]]:\n    config = load_ris_lab_config(config_path)\n    if output_dir is None:\n        output_cfg = config.get(\"output\", {})\n        base_dir = output_cfg.get(\"base_dir\", \"outputs\")\n        run_id = output_cfg.get(\"run_id\")\n        output_path = create_output_dir(base_dir, run_id=run_id)\n    else:\n        output_path = _ensure_output_dir(Path(output_dir))\n\n    summary = snapshot_ris_lab_config(output_path, config)\n    return config, output_path, summary\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "\"\"\"RIS Lab configuration schema and snapshot helpers.\"\"\"\n\nfrom __future__ import annotations\n\nimport copy\nimport hashlib\nimport json\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport yaml\n\nfrom app.io import create_output_dir, save_json, save_yaml\n\nRIS_LAB_SCHEMA_VERSION = 1\n\nDEFAULT_RIS_LAB_CONFIG: Dict[str, Any] = {\n    \"schema_version\": RIS_LAB_SCHEMA_VERSION,\n    \"geometry\": {\n        \"nx\": None,\n        \"ny\": None,\n        \"dx\": None,\n        \"dy\": None,\n        \"origin\": [0.0, 0.0, 0.0],\n        \"normal\": [0.0, 0.0, 1.0],\n        \"x_axis_hint\": [1.0, 0.0, 0.0],\n    },\n    \"control\": {\n        \"mode\": \"uniform\",\n        \"params\": {\"phase_rad\": 0.0},\n    },\n    \"quantization\": {\n        \"bits\": 0,\n    },\n    \"pattern_mode\": {\n        \"normalization\": \"peak_0db\",\n        \"rx_sweep_deg\": {\"start\": -90.0, \"stop\": 90.0, \"step\": 2.0},\n    },\n    \"link_mode\": {\n        \"weighting\": \"inverse_distance\",\n        \"enabled\": False,\n    },\n    \"validation\": {\n        \"normalization\": \"peak_0db\",\n        \"rmse_db_max\": 2.0,\n        \"peak_angle_err_deg_max\": 2.0,\n        \"peak_db_err_max\": 1.5,\n    },\n    \"experiment\": {\n        \"frequency_hz\": 28_000_000_000,\n        \"tx_incident_angle_deg\": -30.0,\n    },\n    \"output\": {\n        \"base_dir\": \"outputs\",\n        \"run_id\": None,\n    },\n}\n\n_ALIAS_FIELDS = {\n    (\"geometry\", \"nx\"): [(\"geometry\", \"n\")],\n    (\"geometry\", \"ny\"): [(\"geometry\", \"m\")],\n    (\"geometry\", \"dx\"): [(\"geometry\", \"dx_m\")],\n    (\"geometry\", \"dy\"): [(\"geometry\", \"dy_m\")],\n}\n\n\ndef _deep_merge(base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]:\n    for key, value in override.items():\n        if isinstance(value, dict) and isinstance(base.get(key), dict):\n            base[key] = _deep_merge(base[key], value)\n        else:\n            base[key] = value\n    return base\n\n\ndef _apply_aliases(config: Dict[str, Any]) -> Dict[str, Any]:\n    updated = copy.deepcopy(config)\n    for (section, key), aliases in _ALIAS_FIELDS.items():\n        section_data = updated.get(section)\n        if not isinstance(section_data, dict):\n            continue\n        if key in section_data:\n            continue\n        for alias_section, alias_key in aliases:\n            alias_data = updated.get(alias_section)\n            if isinstance(alias_data, dict) and alias_key in alias_data:\n                section_data[key] = alias_data[alias_key]\n                break\n        updated[section] = section_data\n    return updated\n\n\ndef _missing_required_fields(geometry: Dict[str, Any]) -> list[str]:\n    required = (\"nx\", \"ny\", \"dx\", \"dy\")\n    missing = []\n    for key in required:\n        value = geometry.get(key)\n        if value is None:\n            missing.append(f\"geometry.{key}\")\n    return missing\n\n\ndef _canonicalize_config(config: Dict[str, Any]) -> Dict[str, Any]:\n    ordered_keys = [\n        \"schema_version\",\n        \"geometry\",\n        \"control\",\n        \"quantization\",\n        \"pattern_mode\",\n        \"link_mode\",\n        \"validation\",\n        \"experiment\",\n        \"output\",\n    ]\n    ordered: Dict[str, Any] = {}\n    for key in ordered_keys:\n        if key in config:\n            ordered[key] = config[key]\n    extras = {k: v for k, v in config.items() if k not in ordered_keys}\n    for key in sorted(extras):\n        ordered[key] = extras[key]\n    return ordered\n\n\ndef resolve_ris_lab_config(raw_config: Dict[str, Any]) -> Dict[str, Any]:\n    if not isinstance(raw_config, dict):\n        raise ValueError(\"RIS Lab config must be a YAML mapping\")\n\n    normalized = _apply_aliases(raw_config)\n    resolved = _deep_merge(copy.deepcopy(DEFAULT_RIS_LAB_CONFIG), normalized)\n\n    geometry = resolved.get(\"geometry\")\n    if not isinstance(geometry, dict):\n        raise ValueError(\"RIS Lab config geometry must be a mapping\")\n\n    missing = _missing_required_fields(geometry)\n    if missing:\n        raise ValueError(\n            \"RIS Lab config missing required fields: \" + \", \".join(missing)\n        )\n\n    return _canonicalize_config(resolved)\n\n\ndef load_ris_lab_config(path: str | Path) -> Dict[str, Any]:\n    config_path = Path(path)\n    if not config_path.exists():\n        raise FileNotFoundError(f\"RIS Lab config not found: {config_path}\")\n    with config_path.open(\"r\", encoding=\"utf-8\") as handle:\n        data = yaml.safe_load(handle)\n    return resolve_ris_lab_config(data)\n\n\ndef compute_ris_lab_config_hash(config: Dict[str, Any]) -> str:\n    payload = json.dumps(config, sort_keys=True).encode(\"utf-8\")\n    return hashlib.sha256(payload).hexdigest()\n\n\ndef _ensure_output_dir(output_dir: Path) -> Path:\n    output_dir.mkdir(parents=True, exist_ok=True)\n    (output_dir / \"plots\").mkdir(parents=True, exist_ok=True)\n    (output_dir / \"data\").mkdir(parents=True, exist_ok=True)\n    return output_dir\n\n\ndef snapshot_ris_lab_config(output_dir: Path, config: Dict[str, Any]) -> Dict[str, Any]:\n    output_dir = _ensure_output_dir(output_dir)\n    yaml_path = output_dir / \"config.yaml\"\n    json_path = output_dir / \"config.json\"\n    save_yaml(yaml_path, config)\n    save_json(json_path, config)\n\n    config_hash = compute_ris_lab_config_hash(config)\n    summary = {\n        \"schema_version\": config.get(\"schema_version\", RIS_LAB_SCHEMA_VERSION),\n        \"config\": {\n            \"hash_sha256\": config_hash,\n            \"path_yaml\": str(yaml_path),\n            \"path_json\": str(json_path),\n        },\n    }\n    save_json(output_dir / \"summary.json\", summary)\n    return summary\n\n\ndef resolve_and_snapshot_ris_lab_config(\n    config_path: str | Path,\n    output_dir: Optional[str | Path] = None,\n) -> tuple[Dict[str, Any], Path, Dict[str, Any]]:\n    config = load_ris_lab_config(config_path)\n    if output_dir is None:\n        output_cfg = config.get(\"output\", {})\n        base_dir = output_cfg.get(\"base_dir\", \"outputs\")\n        run_id = output_cfg.get(\"run_id\")\n        output_path = create_output_dir(base_dir, run_id=run_id)\n    else:\n        output_path = _ensure_output_dir(Path(output_dir))\n\n    summary = snapshot_ris_lab_config(output_path, config)\n    return config, output_path, summary\n"
  }
}

thinking
**Searching for RIS lab code**

I'm looking for run or validate functions related to the RIS lab, starting by checking the app/ris/lab directory to locate relevant code.
exec
/usr/bin/zsh -lc 'rg "ris" app -g "*.py"' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 6ms:
app/config.py:    def ris(self) -> Dict[str, Any]:
app/config.py:        return self.data.get("ris", {})
app/ris/__init__.py:from .ris_config import (  # noqa: F401
app/ris/__init__.py:    compute_ris_lab_config_hash,
app/ris/__init__.py:    load_ris_lab_config,
app/ris/__init__.py:    resolve_and_snapshot_ris_lab_config,
app/ris/__init__.py:    resolve_ris_lab_config,
app/ris/__init__.py:    snapshot_ris_lab_config,
app/ris/__init__.py:from .ris_core import (  # noqa: F401
app/ris/ris_config.py:def resolve_ris_lab_config(raw_config: Dict[str, Any]) -> Dict[str, Any]:
app/ris/ris_config.py:def load_ris_lab_config(path: str | Path) -> Dict[str, Any]:
app/ris/ris_config.py:    return resolve_ris_lab_config(data)
app/ris/ris_config.py:def compute_ris_lab_config_hash(config: Dict[str, Any]) -> str:
app/ris/ris_config.py:def snapshot_ris_lab_config(output_dir: Path, config: Dict[str, Any]) -> Dict[str, Any]:
app/ris/ris_config.py:    config_hash = compute_ris_lab_config_hash(config)
app/ris/ris_config.py:def resolve_and_snapshot_ris_lab_config(
app/ris/ris_config.py:    config = load_ris_lab_config(config_path)
app/ris/ris_config.py:    summary = snapshot_ris_lab_config(output_path, config)
app/utils/system.py:    stub.__dict__["__ris_sionna_stub__"] = reason

thinking
**Clarifying scope and dependencies between US-003 and US-004**

US-003 requires a CLI run/validate entrypoint producing artifacts, but those outputs seem tied to US-004's pattern mode, which isn't implemented yet. Since no stubs are allowed, the plan is to check if existing test or app modules provide runnable functionality to satisfy US-003 without implementing full pattern mode. Next step is auditing related code and tests for existing run/validate logic to orchestrate.
exec
/usr/bin/zsh -lc 'ls -la tests' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 3ms:
total 28
drwxrwxr-x  3 josh josh 4096 Jan 20 18:01 .
drwxrwxr-x 16 josh josh 4096 Jan 20 18:01 ..
drwxrwxr-x  2 josh josh 4096 Jan 20 18:01 __pycache__
-rw-rw-r--  1 josh josh  756 Jan 19 17:55 test_alignment.py
-rw-rw-r--  1 josh josh 2250 Jan 20 18:01 test_ris_config.py
-rw-rw-r--  1 josh josh 2165 Jan 20 17:53 test_ris_core.py
-rw-rw-r--  1 josh josh 1755 Jan 19 17:55 test_ui_smoke.py

thinking
**Planning minimal CLI implementation**

I'm considering adding a CLI entrypoint with "run" and "validate" commands that minimally call existing functions, possibly outputting config snapshots, since full artifact generation like phase_map.png isn't implemented and placeholders aren't allowed. Next, I'll search for existing pattern mode artifact generation to reuse.
exec
/usr/bin/zsh -lc 'rg "phase_map" -n' in /home/josh/Documents/Github/RIS_SIONNA exited 1 in 15ms:


thinking
**Clarifying search approach**
exec
/usr/bin/zsh -lc 'rg "pattern" app -g "*.py"' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 6ms:
app/scene.py:        pattern=tx_arr.get("pattern", "iso"),
app/scene.py:        pattern=rx_arr.get("pattern", "iso"),
app/ris/ris_config.py:    "pattern_mode": {
app/ris/ris_config.py:        "pattern_mode",
app/utils/system.py:        scene.tx_array = rt.PlanarArray(num_rows=1, num_cols=1, pattern="iso", polarization="V")
app/utils/system.py:        scene.rx_array = rt.PlanarArray(num_rows=1, num_cols=1, pattern="iso", polarization="V")


thinking
**Clarifying US-003 scope and artifacts**

US-003 likely requires implementing a minimal CLI run/validate that produces expected artifact outputs for acceptance without full pattern mode logic, avoiding overlap with US-004 features still pending.
thinking
**Investigating core for minimal pattern run**

I'm checking US-001/US-002 and ris_core for existing runner logic to support a minimal pattern mode run that generates required artifacts without full US-004/005 implementation.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_core.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_core.py"}) success in 1ms:
{
  "content": [
    {
      "text": "\"\"\"Core RIS math primitives for geometry and phase control.\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Iterable, Optional\n\nimport numpy as np\n\n\n@dataclass(frozen=True)\nclass RisFrame:\n    \"\"\"Right-handed local frame for the RIS surface.\"\"\"\n\n    u: np.ndarray\n    v: np.ndarray\n    w: np.ndarray\n\n\n@dataclass(frozen=True)\nclass RisGeometry:\n    \"\"\"RIS element centers and local frame.\"\"\"\n\n    centers: np.ndarray\n    frame: RisFrame\n\n\n_DEFAULT_NORMAL = np.array([0.0, 0.0, 1.0], dtype=float)\n_DEFAULT_X_AXIS = np.array([1.0, 0.0, 0.0], dtype=float)\n_ALT_X_AXIS = np.array([0.0, 1.0, 0.0], dtype=float)\n\n\ndef _normalize(vec: np.ndarray, name: str) -> np.ndarray:\n    norm = np.linalg.norm(vec)\n    if norm <= 0.0:\n        raise ValueError(f\"{name} must be a non-zero vector\")\n    return vec / norm\n\n\ndef compute_local_frame(\n    normal: Optional[Iterable[float]] = None,\n    x_axis_hint: Optional[Iterable[float]] = None,\n) -> RisFrame:\n    \"\"\"Return a stable, right-handed local frame for a surface.\"\"\"\n\n    w = _normalize(\n        np.array(_DEFAULT_NORMAL if normal is None else normal, dtype=float), \"normal\"\n    )\n    hint = np.array(_DEFAULT_X_AXIS if x_axis_hint is None else x_axis_hint, dtype=float)\n    hint = _normalize(hint, \"x_axis_hint\")\n    if abs(np.dot(hint, w)) > 0.99:\n        hint = _ALT_X_AXIS\n        if abs(np.dot(hint, w)) > 0.99:\n            hint = _DEFAULT_X_AXIS\n    u = _normalize(hint - np.dot(hint, w) * w, \"x_axis_hint\")\n    v = np.cross(w, u)\n    return RisFrame(u=u, v=v, w=w)\n\n\ndef compute_element_centers(\n    nx: int,\n    ny: int,\n    dx: float,\n    dy: float,\n    origin: Optional[Iterable[float]] = None,\n    normal: Optional[Iterable[float]] = None,\n    x_axis_hint: Optional[Iterable[float]] = None,\n) -> RisGeometry:\n    \"\"\"Compute RIS element centers with stable ordering (row-major).\"\"\"\n\n    if nx <= 0 or ny <= 0:\n        raise ValueError(\"nx and ny must be positive\")\n    if dx <= 0.0 or dy <= 0.0:\n        raise ValueError(\"dx and dy must be positive\")\n\n    frame = compute_local_frame(normal=normal, x_axis_hint=x_axis_hint)\n    origin_vec = np.array(origin if origin is not None else [0.0, 0.0, 0.0], dtype=float)\n\n    x_offsets = (np.arange(nx, dtype=float) - (nx - 1) / 2.0) * dx\n    y_offsets = (np.arange(ny, dtype=float) - (ny - 1) / 2.0) * dy\n\n    centers = (\n        origin_vec\n        + x_offsets[None, :, None] * frame.u[None, None, :]\n        + y_offsets[:, None, None] * frame.v[None, None, :]\n    )\n    return RisGeometry(centers=centers, frame=frame)\n\n\ndef synthesize_uniform_phase(shape: tuple[int, int], phase_rad: float = 0.0) -> np.ndarray:\n    \"\"\"Return a uniform phase map.\"\"\"\n\n    return np.full(shape, float(phase_rad), dtype=float)\n\n\ndef synthesize_custom_phase(phase_rad: np.ndarray, shape: Optional[tuple[int, int]] = None) -> np.ndarray:\n    \"\"\"Validate and return a custom phase map.\"\"\"\n\n    phase = np.array(phase_rad, dtype=float)\n    if shape is not None and phase.shape != shape:\n        raise ValueError(f\"custom phase shape {phase.shape} does not match {shape}\")\n    return phase\n\n\ndef synthesize_steering_phase(\n    centers: np.ndarray,\n    wavelength: float,\n    direction: Iterable[float],\n) -> np.ndarray:\n    \"\"\"Far-field steering phase for a desired direction.\"\"\"\n\n    k = 2.0 * np.pi / float(wavelength)\n    direction_vec = _normalize(np.array(direction, dtype=float), \"direction\")\n    phase = -k * np.tensordot(centers, direction_vec, axes=([2], [0]))\n    return phase\n\n\ndef synthesize_focusing_phase(\n    centers: np.ndarray,\n    wavelength: float,\n    focal_point: Iterable[float],\n) -> np.ndarray:\n    \"\"\"Near-field focusing phase towards a focal point.\"\"\"\n\n    k = 2.0 * np.pi / float(wavelength)\n    focal = np.array(focal_point, dtype=float)\n    distances = np.linalg.norm(centers - focal[None, None, :], axis=2)\n    phase = -k * distances\n    return phase\n\n\ndef quantize_phase(phase_rad: np.ndarray, bits: Optional[int]) -> np.ndarray:\n    \"\"\"Quantize phase in radians using 1-bit or 2-bit levels.\"\"\"\n\n    if bits in (None, 0):\n        return np.array(phase_rad, dtype=float, copy=True)\n    if bits not in (1, 2):\n        raise ValueError(\"quantization_bits must be one of {0, 1, 2}\")\n\n    phase = np.array(phase_rad, dtype=float)\n    step = 2.0 * np.pi / (2**bits)\n    levels = np.arange(2**bits, dtype=float) * step\n    phase_wrapped = np.mod(phase, 2.0 * np.pi)\n    diffs = np.abs(phase_wrapped[..., None] - levels)\n    indices = np.argmin(diffs, axis=-1)\n    return levels[indices]\n\n\ndef radians_to_degrees(angle_rad: np.ndarray) -> np.ndarray:\n    \"\"\"Convert radians to degrees.\"\"\"\n\n    return np.rad2deg(angle_rad)\n\n\ndef degrees_to_radians(angle_deg: np.ndarray) -> np.ndarray:\n    \"\"\"Convert degrees to radians.\"\"\"\n\n    return np.deg2rad(angle_deg)\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "\"\"\"Core RIS math primitives for geometry and phase control.\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Iterable, Optional\n\nimport numpy as np\n\n\n@dataclass(frozen=True)\nclass RisFrame:\n    \"\"\"Right-handed local frame for the RIS surface.\"\"\"\n\n    u: np.ndarray\n    v: np.ndarray\n    w: np.ndarray\n\n\n@dataclass(frozen=True)\nclass RisGeometry:\n    \"\"\"RIS element centers and local frame.\"\"\"\n\n    centers: np.ndarray\n    frame: RisFrame\n\n\n_DEFAULT_NORMAL = np.array([0.0, 0.0, 1.0], dtype=float)\n_DEFAULT_X_AXIS = np.array([1.0, 0.0, 0.0], dtype=float)\n_ALT_X_AXIS = np.array([0.0, 1.0, 0.0], dtype=float)\n\n\ndef _normalize(vec: np.ndarray, name: str) -> np.ndarray:\n    norm = np.linalg.norm(vec)\n    if norm <= 0.0:\n        raise ValueError(f\"{name} must be a non-zero vector\")\n    return vec / norm\n\n\ndef compute_local_frame(\n    normal: Optional[Iterable[float]] = None,\n    x_axis_hint: Optional[Iterable[float]] = None,\n) -> RisFrame:\n    \"\"\"Return a stable, right-handed local frame for a surface.\"\"\"\n\n    w = _normalize(\n        np.array(_DEFAULT_NORMAL if normal is None else normal, dtype=float), \"normal\"\n    )\n    hint = np.array(_DEFAULT_X_AXIS if x_axis_hint is None else x_axis_hint, dtype=float)\n    hint = _normalize(hint, \"x_axis_hint\")\n    if abs(np.dot(hint, w)) > 0.99:\n        hint = _ALT_X_AXIS\n        if abs(np.dot(hint, w)) > 0.99:\n            hint = _DEFAULT_X_AXIS\n    u = _normalize(hint - np.dot(hint, w) * w, \"x_axis_hint\")\n    v = np.cross(w, u)\n    return RisFrame(u=u, v=v, w=w)\n\n\ndef compute_element_centers(\n    nx: int,\n    ny: int,\n    dx: float,\n    dy: float,\n    origin: Optional[Iterable[float]] = None,\n    normal: Optional[Iterable[float]] = None,\n    x_axis_hint: Optional[Iterable[float]] = None,\n) -> RisGeometry:\n    \"\"\"Compute RIS element centers with stable ordering (row-major).\"\"\"\n\n    if nx <= 0 or ny <= 0:\n        raise ValueError(\"nx and ny must be positive\")\n    if dx <= 0.0 or dy <= 0.0:\n        raise ValueError(\"dx and dy must be positive\")\n\n    frame = compute_local_frame(normal=normal, x_axis_hint=x_axis_hint)\n    origin_vec = np.array(origin if origin is not None else [0.0, 0.0, 0.0], dtype=float)\n\n    x_offsets = (np.arange(nx, dtype=float) - (nx - 1) / 2.0) * dx\n    y_offsets = (np.arange(ny, dtype=float) - (ny - 1) / 2.0) * dy\n\n    centers = (\n        origin_vec\n        + x_offsets[None, :, None] * frame.u[None, None, :]\n        + y_offsets[:, None, None] * frame.v[None, None, :]\n    )\n    return RisGeometry(centers=centers, frame=frame)\n\n\ndef synthesize_uniform_phase(shape: tuple[int, int], phase_rad: float = 0.0) -> np.ndarray:\n    \"\"\"Return a uniform phase map.\"\"\"\n\n    return np.full(shape, float(phase_rad), dtype=float)\n\n\ndef synthesize_custom_phase(phase_rad: np.ndarray, shape: Optional[tuple[int, int]] = None) -> np.ndarray:\n    \"\"\"Validate and return a custom phase map.\"\"\"\n\n    phase = np.array(phase_rad, dtype=float)\n    if shape is not None and phase.shape != shape:\n        raise ValueError(f\"custom phase shape {phase.shape} does not match {shape}\")\n    return phase\n\n\ndef synthesize_steering_phase(\n    centers: np.ndarray,\n    wavelength: float,\n    direction: Iterable[float],\n) -> np.ndarray:\n    \"\"\"Far-field steering phase for a desired direction.\"\"\"\n\n    k = 2.0 * np.pi / float(wavelength)\n    direction_vec = _normalize(np.array(direction, dtype=float), \"direction\")\n    phase = -k * np.tensordot(centers, direction_vec, axes=([2], [0]))\n    return phase\n\n\ndef synthesize_focusing_phase(\n    centers: np.ndarray,\n    wavelength: float,\n    focal_point: Iterable[float],\n) -> np.ndarray:\n    \"\"\"Near-field focusing phase towards a focal point.\"\"\"\n\n    k = 2.0 * np.pi / float(wavelength)\n    focal = np.array(focal_point, dtype=float)\n    distances = np.linalg.norm(centers - focal[None, None, :], axis=2)\n    phase = -k * distances\n    return phase\n\n\ndef quantize_phase(phase_rad: np.ndarray, bits: Optional[int]) -> np.ndarray:\n    \"\"\"Quantize phase in radians using 1-bit or 2-bit levels.\"\"\"\n\n    if bits in (None, 0):\n        return np.array(phase_rad, dtype=float, copy=True)\n    if bits not in (1, 2):\n        raise ValueError(\"quantization_bits must be one of {0, 1, 2}\")\n\n    phase = np.array(phase_rad, dtype=float)\n    step = 2.0 * np.pi / (2**bits)\n    levels = np.arange(2**bits, dtype=float) * step\n    phase_wrapped = np.mod(phase, 2.0 * np.pi)\n    diffs = np.abs(phase_wrapped[..., None] - levels)\n    indices = np.argmin(diffs, axis=-1)\n    return levels[indices]\n\n\ndef radians_to_degrees(angle_rad: np.ndarray) -> np.ndarray:\n    \"\"\"Convert radians to degrees.\"\"\"\n\n    return np.rad2deg(angle_rad)\n\n\ndef degrees_to_radians(angle_deg: np.ndarray) -> np.ndarray:\n    \"\"\"Convert degrees to radians.\"\"\"\n\n    return np.deg2rad(angle_deg)\n"
  }
}


thinking
**Deciding minimal run implementation with artifact output**

The CLI entrypoint must implement a minimal pattern run producing required artifacts (phase_map.png, pattern plots, metrics.json) to satisfy acceptance, overlapping with future work but scoped minimally now using simple computations from ris_core.
thinking
**Planning minimal validate command**

The validate command must exist and accept a ref file per acceptance; to avoid stubbing, it should perform minimal meaningful checks like loading config and reference file without full metrics yet, focusing on implementing CLI parsing and basic functionality.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/io.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/io.py"}) success in 1ms:
{
  "content": [
    {
      "text": "import json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport yaml\nimport numpy as np\n\n\ndef generate_run_id() -> str:\n    return datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n\n\ndef create_output_dir(base_dir: str, run_id: Optional[str] = None) -> Path:\n    run_id = run_id or generate_run_id()\n    root = Path(base_dir) / run_id\n    (root / \"plots\").mkdir(parents=True, exist_ok=True)\n    (root / \"data\").mkdir(parents=True, exist_ok=True)\n    return root\n\n\ndef find_latest_output_dir(base_dir: str) -> Optional[Path]:\n    root = Path(base_dir)\n    if not root.exists():\n        return None\n    candidates = [p for p in root.iterdir() if p.is_dir() and not p.name.startswith(\"_\")]\n    if not candidates:\n        return None\n    return sorted(candidates)[-1]\n\n\ndef save_yaml(path: Path, data: Dict[str, Any]) -> None:\n    with path.open(\"w\", encoding=\"utf-8\") as f:\n        yaml.safe_dump(data, f, sort_keys=False)\n\n\ndef _json_default(obj: Any):\n    if isinstance(obj, (str, int, float, bool)) or obj is None:\n        return obj\n    if isinstance(obj, (np.generic,)):\n        return obj.item()\n    if hasattr(obj, \"tolist\"):\n        return obj.tolist()\n    try:\n        return float(obj)\n    except Exception:\n        return str(obj)\n\n\ndef save_json(path: Path, data: Dict[str, Any]) -> None:\n    with path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2, default=_json_default)\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "import json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport yaml\nimport numpy as np\n\n\ndef generate_run_id() -> str:\n    return datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n\n\ndef create_output_dir(base_dir: str, run_id: Optional[str] = None) -> Path:\n    run_id = run_id or generate_run_id()\n    root = Path(base_dir) / run_id\n    (root / \"plots\").mkdir(parents=True, exist_ok=True)\n    (root / \"data\").mkdir(parents=True, exist_ok=True)\n    return root\n\n\ndef find_latest_output_dir(base_dir: str) -> Optional[Path]:\n    root = Path(base_dir)\n    if not root.exists():\n        return None\n    candidates = [p for p in root.iterdir() if p.is_dir() and not p.name.startswith(\"_\")]\n    if not candidates:\n        return None\n    return sorted(candidates)[-1]\n\n\ndef save_yaml(path: Path, data: Dict[str, Any]) -> None:\n    with path.open(\"w\", encoding=\"utf-8\") as f:\n        yaml.safe_dump(data, f, sort_keys=False)\n\n\ndef _json_default(obj: Any):\n    if isinstance(obj, (str, int, float, bool)) or obj is None:\n        return obj\n    if isinstance(obj, (np.generic,)):\n        return obj.item()\n    if hasattr(obj, \"tolist\"):\n        return obj.tolist()\n    try:\n        return float(obj)\n    except Exception:\n        return str(obj)\n\n\ndef save_json(path: Path, data: Dict[str, Any]) -> None:\n    with path.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2, default=_json_default)\n"
  }
}

thinking
**Checking existing logging utilities**

I'm looking into the utils.logging module to see if it provides the logger functionality needed.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/utils/logging.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/utils/logging.py"}) success in 1ms:
{
  "content": [
    {
      "text": "import logging\n\n\ndef setup_logging(level: str = \"INFO\") -> None:\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s | %(levelname)s | %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "import logging\n\n\ndef setup_logging(level: str = \"INFO\") -> None:\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s | %(levelname)s | %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n"
  }
}


thinking
**Designing CLI structure for RIS commands**

I'm planning a nested CLI under `app ris` with `run` and `validate` subcommands that accept config, mode, and reference file arguments. The run command will generate phase map and pattern plots plus metrics, logging run details and handling argument validation via argparse choices. Next, I'll stub minimal runner logic to produce required outputs.
thinking
**Defining minimal pattern computation and metrics**

I'm outlining pattern calculation using phase maps and element centers from config, computing array factor over scan angles in the RIS normal plane, and normalizing patterns per mode. I'll generate phase_map.png and minimal metrics.json with peak angle and values to meet requirements, leveraging matplotlib for plots as done elsewhere. Next, I'll inspect plotting utilities to reuse.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/plots.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/plots.py"}) success in 1ms:
{
  "content": [
    {
      "text": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any, Dict, Tuple\n\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401\nimport numpy as np\n\n\ndef _load_npz(path: Path) -> Dict[str, Any]:\n    with np.load(path) as data:\n        return {k: data[k] for k in data.files}\n\n\ndef _infer_cell_size(cell_centers: np.ndarray) -> Tuple[float, float]:\n    if cell_centers.ndim < 3:\n        return 0.0, 0.0\n    xs = cell_centers[:, :, 0]\n    ys = cell_centers[:, :, 1]\n    x_diffs = np.diff(xs, axis=1).ravel()\n    y_diffs = np.diff(ys, axis=0).ravel()\n    x_nonzero = x_diffs[x_diffs != 0]\n    y_nonzero = y_diffs[y_diffs != 0]\n    x_step = np.median(np.abs(x_nonzero)) if x_nonzero.size else 0.0\n    y_step = np.median(np.abs(y_nonzero)) if y_nonzero.size else 0.0\n    return float(x_step or 0.0), float(y_step or 0.0)\n\n\ndef compute_radio_map_extent(cell_centers: np.ndarray) -> Tuple[float, float, float, float]:\n    xs = cell_centers[:, :, 0]\n    ys = cell_centers[:, :, 1]\n    cell_size_x, cell_size_y = _infer_cell_size(cell_centers)\n    return (\n        float(xs.min() - cell_size_x * 0.5),\n        float(xs.max() + cell_size_x * 0.5),\n        float(ys.min() - cell_size_y * 0.5),\n        float(ys.max() + cell_size_y * 0.5),\n    )\n\n\ndef plot_radio_map(\n    metric_map: np.ndarray,\n    cell_centers: np.ndarray,\n    output_dir: Path,\n    metric_label: str,\n    filename_prefix: str,\n    tx_pos: np.ndarray | None = None,\n    rx_pos: np.ndarray | None = None,\n) -> Tuple[Path, Path]:\n    # metric_map: [num_tx, y, x]\n    # cell_centers: [y, x, 3]\n\n    extent = compute_radio_map_extent(cell_centers)\n\n    fig, ax = plt.subplots(figsize=(7, 5))\n    im = ax.imshow(metric_map[0], origin=\"lower\", extent=extent, cmap=\"viridis\")\n    ax.set_title(f\"Radio Map ({metric_label})\")\n    ax.set_xlabel(\"x [m]\")\n    ax.set_ylabel(\"y [m]\")\n    if tx_pos is not None:\n        ax.scatter([tx_pos[0]], [tx_pos[1]], color=\"#dc322f\", s=30, label=\"Tx\")\n    if rx_pos is not None:\n        ax.scatter([rx_pos[0]], [rx_pos[1]], color=\"#268bd2\", s=30, label=\"Rx\")\n    if tx_pos is not None or rx_pos is not None:\n        ax.legend(loc=\"upper right\")\n    fig.colorbar(im, ax=ax, label=metric_label)\n    fig.tight_layout()\n\n    png_path = output_dir / f\"{filename_prefix}.png\"\n    svg_path = output_dir / f\"{filename_prefix}.svg\"\n    fig.savefig(png_path, dpi=200)\n    fig.savefig(svg_path)\n    plt.close(fig)\n\n    return png_path, svg_path\n\n\ndef plot_radio_map_from_npz(\n    npz_path: Path,\n    output_dir: Path,\n    metric_key: str,\n    metric_label: str,\n    filename_prefix: str,\n) -> Tuple[Path, Path]:\n    data = _load_npz(npz_path)\n    return plot_radio_map(\n        metric_map=data[metric_key],\n        cell_centers=data[\"cell_centers\"],\n        output_dir=output_dir,\n        metric_label=metric_label,\n        filename_prefix=filename_prefix,\n    )\n\n\ndef plot_histogram(\n    data: np.ndarray,\n    weights: np.ndarray | None,\n    output_dir: Path,\n    title: str,\n    xlabel: str,\n    filename_prefix: str,\n    bins: int = 50,\n) -> Tuple[Path, Path]:\n    fig, ax = plt.subplots(figsize=(7, 4))\n    ax.hist(data, bins=bins, weights=weights, color=\"#1f77b4\", alpha=0.85)\n    ax.set_title(title)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(\"Weighted count\" if weights is not None else \"Count\")\n    fig.tight_layout()\n\n    png_path = output_dir / f\"{filename_prefix}.png\"\n    svg_path = output_dir / f\"{filename_prefix}.svg\"\n    fig.savefig(png_path, dpi=200)\n    fig.savefig(svg_path)\n    plt.close(fig)\n    return png_path, svg_path\n\n\ndef plot_rays_3d(\n    segments: np.ndarray,\n    tx_pos: np.ndarray,\n    rx_pos: np.ndarray,\n    output_dir: Path,\n    filename_prefix: str = \"ray_paths_3d\",\n) -> Tuple[Path, Path]:\n    fig = plt.figure(figsize=(7, 5))\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_title(\"RF Ray Paths (3D)\")\n    ax.set_xlabel(\"x [m]\")\n    ax.set_ylabel(\"y [m]\")\n    ax.set_zlabel(\"z [m]\")\n\n    for row in segments:\n        _, x0, y0, z0, x1, y1, z1 = row\n        ax.plot([x0, x1], [y0, y1], [z0, z1], color=\"#ff9750\", alpha=0.7, linewidth=1.0)\n\n    ax.scatter([tx_pos[0]], [tx_pos[1]], [tx_pos[2]], color=\"#dc322f\", s=30, label=\"Tx\")\n    ax.scatter([rx_pos[0]], [rx_pos[1]], [rx_pos[2]], color=\"#268bd2\", s=30, label=\"Rx\")\n    ax.legend(loc=\"upper right\")\n\n    fig.tight_layout()\n    png_path = output_dir / f\"{filename_prefix}.png\"\n    svg_path = output_dir / f\"{filename_prefix}.svg\"\n    fig.savefig(png_path, dpi=200)\n    fig.savefig(svg_path)\n    plt.close(fig)\n    return png_path, svg_path\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Any, Dict, Tuple\n\nimport matplotlib\nmatplotlib.use(\"Agg\")\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D  # noqa: F401\nimport numpy as np\n\n\ndef _load_npz(path: Path) -> Dict[str, Any]:\n    with np.load(path) as data:\n        return {k: data[k] for k in data.files}\n\n\ndef _infer_cell_size(cell_centers: np.ndarray) -> Tuple[float, float]:\n    if cell_centers.ndim < 3:\n        return 0.0, 0.0\n    xs = cell_centers[:, :, 0]\n    ys = cell_centers[:, :, 1]\n    x_diffs = np.diff(xs, axis=1).ravel()\n    y_diffs = np.diff(ys, axis=0).ravel()\n    x_nonzero = x_diffs[x_diffs != 0]\n    y_nonzero = y_diffs[y_diffs != 0]\n    x_step = np.median(np.abs(x_nonzero)) if x_nonzero.size else 0.0\n    y_step = np.median(np.abs(y_nonzero)) if y_nonzero.size else 0.0\n    return float(x_step or 0.0), float(y_step or 0.0)\n\n\ndef compute_radio_map_extent(cell_centers: np.ndarray) -> Tuple[float, float, float, float]:\n    xs = cell_centers[:, :, 0]\n    ys = cell_centers[:, :, 1]\n    cell_size_x, cell_size_y = _infer_cell_size(cell_centers)\n    return (\n        float(xs.min() - cell_size_x * 0.5),\n        float(xs.max() + cell_size_x * 0.5),\n        float(ys.min() - cell_size_y * 0.5),\n        float(ys.max() + cell_size_y * 0.5),\n    )\n\n\ndef plot_radio_map(\n    metric_map: np.ndarray,\n    cell_centers: np.ndarray,\n    output_dir: Path,\n    metric_label: str,\n    filename_prefix: str,\n    tx_pos: np.ndarray | None = None,\n    rx_pos: np.ndarray | None = None,\n) -> Tuple[Path, Path]:\n    # metric_map: [num_tx, y, x]\n    # cell_centers: [y, x, 3]\n\n    extent = compute_radio_map_extent(cell_centers)\n\n    fig, ax = plt.subplots(figsize=(7, 5))\n    im = ax.imshow(metric_map[0], origin=\"lower\", extent=extent, cmap=\"viridis\")\n    ax.set_title(f\"Radio Map ({metric_label})\")\n    ax.set_xlabel(\"x [m]\")\n    ax.set_ylabel(\"y [m]\")\n    if tx_pos is not None:\n        ax.scatter([tx_pos[0]], [tx_pos[1]], color=\"#dc322f\", s=30, label=\"Tx\")\n    if rx_pos is not None:\n        ax.scatter([rx_pos[0]], [rx_pos[1]], color=\"#268bd2\", s=30, label=\"Rx\")\n    if tx_pos is not None or rx_pos is not None:\n        ax.legend(loc=\"upper right\")\n    fig.colorbar(im, ax=ax, label=metric_label)\n    fig.tight_layout()\n\n    png_path = output_dir / f\"{filename_prefix}.png\"\n    svg_path = output_dir / f\"{filename_prefix}.svg\"\n    fig.savefig(png_path, dpi=200)\n    fig.savefig(svg_path)\n    plt.close(fig)\n\n    return png_path, svg_path\n\n\ndef plot_radio_map_from_npz(\n    npz_path: Path,\n    output_dir: Path,\n    metric_key: str,\n    metric_label: str,\n    filename_prefix: str,\n) -> Tuple[Path, Path]:\n    data = _load_npz(npz_path)\n    return plot_radio_map(\n        metric_map=data[metric_key],\n        cell_centers=data[\"cell_centers\"],\n        output_dir=output_dir,\n        metric_label=metric_label,\n        filename_prefix=filename_prefix,\n    )\n\n\ndef plot_histogram(\n    data: np.ndarray,\n    weights: np.ndarray | None,\n    output_dir: Path,\n    title: str,\n    xlabel: str,\n    filename_prefix: str,\n    bins: int = 50,\n) -> Tuple[Path, Path]:\n    fig, ax = plt.subplots(figsize=(7, 4))\n    ax.hist(data, bins=bins, weights=weights, color=\"#1f77b4\", alpha=0.85)\n    ax.set_title(title)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(\"Weighted count\" if weights is not None else \"Count\")\n    fig.tight_layout()\n\n    png_path = output_dir / f\"{filename_prefix}.png\"\n    svg_path = output_dir / f\"{filename_prefix}.svg\"\n    fig.savefig(png_path, dpi=200)\n    fig.savefig(svg_path)\n    plt.close(fig)\n    return png_path, svg_path\n\n\ndef plot_rays_3d(\n    segments: np.ndarray,\n    tx_pos: np.ndarray,\n    rx_pos: np.ndarray,\n    output_dir: Path,\n    filename_prefix: str = \"ray_paths_3d\",\n) -> Tuple[Path, Path]:\n    fig = plt.figure(figsize=(7, 5))\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.set_title(\"RF Ray Paths (3D)\")\n    ax.set_xlabel(\"x [m]\")\n    ax.set_ylabel(\"y [m]\")\n    ax.set_zlabel(\"z [m]\")\n\n    for row in segments:\n        _, x0, y0, z0, x1, y1, z1 = row\n        ax.plot([x0, x1], [y0, y1], [z0, z1], color=\"#ff9750\", alpha=0.7, linewidth=1.0)\n\n    ax.scatter([tx_pos[0]], [tx_pos[1]], [tx_pos[2]], color=\"#dc322f\", s=30, label=\"Tx\")\n    ax.scatter([rx_pos[0]], [rx_pos[1]], [rx_pos[2]], color=\"#268bd2\", s=30, label=\"Rx\")\n    ax.legend(loc=\"upper right\")\n\n    fig.tight_layout()\n    png_path = output_dir / f\"{filename_prefix}.png\"\n    svg_path = output_dir / f\"{filename_prefix}.svg\"\n    fig.savefig(png_path, dpi=200)\n    fig.savefig(svg_path)\n    plt.close(fig)\n    return png_path, svg_path\n"
  }
}


thinking
**Weighing validation scope**

I'm considering implementing a basic validation that reads the reference file, runs pattern mode, computes some metrics, and writes metrics.json to satisfy the "validate" command comprehensively, even though this overlaps with a later story; this avoids placeholders while keeping outputs minimal.
thinking
**Clarifying CLI validation scope**

I'm deciding to implement a minimal but functional validate command limited to CSV reference files with basic metric computations and plots, avoiding advanced US-005 features while ensuring real validation output and logging. I'm planning a new ris_lab module with run and validate modes that resolve configs, compute patterns, save plots, and write metrics.json including run metadata and logs.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/Makefile"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/Makefile"}) success in 1ms:
{
  "content": [
    {
      "text": ".PHONY: run diagnose plot dashboard sim\n\nrun:\n\tpython -m app run --config configs/default.yaml\n\ndiagnose:\n\tpython -m app diagnose\n\nplot:\n\tpython -m app plot --latest\n\ndashboard:\n\tpython -m app dashboard\n\nsim:\n\tpython -m app sim\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": ".PHONY: run diagnose plot dashboard sim\n\nrun:\n\tpython -m app run --config configs/default.yaml\n\ndiagnose:\n\tpython -m app diagnose\n\nplot:\n\tpython -m app plot --latest\n\ndashboard:\n\tpython -m app dashboard\n\nsim:\n\tpython -m app sim\n"
  }
}


thinking
**Planning RIS module implementation**

I'm deciding to create a new module under app/ris for RIS run and validation, updating the CLI to support config-based pattern mode, and possibly adjusting __init__.py for imports. Docs updates seem unnecessary for now.
thinking
**Designing RIS phase and pattern computation**

I'm outlining functions to load control phases with multiple modes, compute directions from angles, and calculate pattern responses by matrix operations on element centers and directions. The plan includes saving phase maps and pattern plots in output subfolders while ensuring required artifacts like phase_map.png exist in the output root.
exec
/usr/bin/zsh -lc 'ls -la outputs' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 3ms:
total 48
drwxrwxr-x  7 josh josh  4096 Jan 20 16:23 .
drwxrwxr-x 16 josh josh  4096 Jan 20 18:01 ..
drwxrwxr-x  4 josh josh  4096 Jan 19 20:23 20260119_202350
drwxrwxr-x  4 josh josh  4096 Jan 19 20:30 20260119_203004
drwxrwxr-x  4 josh josh  4096 Jan 19 20:34 20260119_203403
drwxrwxr-x  4 josh josh  4096 Jan 19 20:34 20260119_203427
drwxrwxr-x  5 josh josh  4096 Jan 19 20:59 _cache
-rw-rw-r--  1 josh josh 16395 Jan 19 23:09 _sim_jobs.json


thinking
**Planning output file locations and logging**

I’m deciding to save key images both in the output directory root and in a plots subfolder for clarity, accepting some duplication. Metrics.json will go in the output root, and logs will include run ID, mode, and output directory. I'll also ensure CLI uses argparse choices for valid modes and handles exit codes and exceptions consistent with existing patterns.
thinking
**Designing RIS CLI and core module**

I'm outlining a new RIS subcommand with run and validate subparsers, supporting modes "pattern" and "link" where link mode computes a minimal single-angle link gain. I'll implement core RIS logic in a new module with pattern computation, plotting, normalization, and validation comparing against CSV references. Outputs include metrics, plots, and phase maps organized under standard output and plots directories, respecting existing logging and error handling patterns.
file update
A /home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_lab.py
"""RIS Lab runners for pattern and validation modes."""

from __future__ import annotations

import csv
import logging
from pathlib import Path
from typing import Any, Dict, Tuple

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np

from app.io import save_json
from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
from app.ris.ris_core import (
    compute_element_centers,
    degrees_to_radians,
    quantize_phase,
    synthesize_custom_phase,
    synthesize_focusing_phase,
    synthesize_steering_phase,
    synthesize_uniform_phase,
)

logger = logging.getLogger(__name__)

_SPEED_OF_LIGHT_M_S = 299_792_458.0
_DB_FLOOR = 1e-12


def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
    az = float(azimuth_deg)
    el = float(elevation_deg)
    az_rad = np.deg2rad(az)
    el_rad = np.deg2rad(el)
    return np.array(
        [
            np.cos(el_rad) * np.cos(az_rad),
            np.cos(el_rad) * np.sin(az_rad),
            np.sin(el_rad),
        ],
        dtype=float,
    )


def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
    geometry_cfg = config["geometry"]
    geometry = compute_element_centers(
        nx=int(geometry_cfg["nx"]),
        ny=int(geometry_cfg["ny"]),
        dx=float(geometry_cfg["dx"]),
        dy=float(geometry_cfg["dy"]),
        origin=geometry_cfg.get("origin"),
        normal=geometry_cfg.get("normal"),
        x_axis_hint=geometry_cfg.get("x_axis_hint"),
    )

    control_cfg = config.get("control", {})
    mode = control_cfg.get("mode", "uniform")
    params = control_cfg.get("params", {}) or {}
    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))

    if mode == "uniform":
        if "phase_rad" in params:
            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
        elif "phase_deg" in params:
            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
        else:
            phase = synthesize_uniform_phase(shape, 0.0)
    elif mode == "steer":
        direction = params.get("direction")
        if direction is None:
            az = params.get("azimuth_deg")
            el = params.get("elevation_deg")
            if az is None or el is None:
                raise ValueError(
                    "steer control requires direction or azimuth_deg/elevation_deg"
                )
            direction = _direction_from_angles(float(az), float(el))
        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
    elif mode == "focus":
        focal_point = params.get("focal_point")
        if focal_point is None:
            raise ValueError("focus control requires focal_point")
        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
    elif mode == "custom":
        phase_map = params.get("phase_map")
        if phase_map is None:
            raise ValueError("custom control requires phase_map")
        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
    else:
        raise ValueError(f"Unsupported control mode: {mode}")

    quant_bits = config.get("quantization", {}).get("bits")
    phase = quantize_phase(phase, quant_bits)
    return phase


def _compute_array_response(
    centers: np.ndarray,
    phase_map: np.ndarray,
    frame: Any,
    wavelength: float,
    theta_deg: np.ndarray,
) -> np.ndarray:
    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
    centers_flat = centers.reshape(-1, 3)
    phase_flat = phase_map.reshape(-1)
    phase_incident = centers_flat @ directions.T
    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
    response = np.exp(1j * total_phase).sum(axis=0)
    return np.abs(response) ** 2


def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
    if mode is None:
        return linear
    if mode == "peak_0db":
        peak = np.max(linear)
        return linear / peak if peak > 0 else linear
    if mode == "unit_power":
        mean = np.mean(linear)
        return linear / mean if mean > 0 else linear
    raise ValueError(f"Unsupported normalization mode: {mode}")


def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
    fig, ax = plt.subplots(figsize=(6, 5))
    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
    ax.set_title("RIS Phase Map [rad]")
    ax.set_xlabel("Element X")
    ax.set_ylabel("Element Y")
    fig.colorbar(im, ax=ax, label="Phase [rad]")
    fig.tight_layout()
    path = output_dir / "phase_map.png"
    fig.savefig(path, dpi=200)
    plt.close(fig)
    return path


def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
    ax.set_title("RIS Pattern (Normalized)")
    ax.set_xlabel("Rx angle [deg]")
    ax.set_ylabel("Gain [dB]")
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    cartesian_path = output_dir / "pattern_cartesian.png"
    fig.savefig(cartesian_path, dpi=200)
    plt.close(fig)

    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection="polar")
    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
    ax.set_title("RIS Pattern (Polar)")
    ax.set_theta_zero_location("N")
    ax.set_theta_direction(-1)
    fig.tight_layout()
    polar_path = output_dir / "pattern_polar.png"
    fig.savefig(polar_path, dpi=200)
    plt.close(fig)
    return cartesian_path, polar_path


def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
    with path.open("r", encoding="utf-8") as handle:
        reader = csv.DictReader(handle)
        if reader.fieldnames is None:
            raise ValueError("Reference CSV must include header row")
        fields = {name.strip() for name in reader.fieldnames}
        if "theta_deg" not in fields:
            raise ValueError("Reference CSV missing required column: theta_deg")
        if "pattern_db" not in fields and "pattern_linear" not in fields:
            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")

        theta_vals = []
        pattern_vals = []
        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
        for row in reader:
            theta_vals.append(float(row["theta_deg"]))
            pattern_vals.append(float(row[pattern_kind]))
    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind


def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
    save_json(output_dir / "metrics.json", metrics)


def run_ris_lab(config_path: str, mode: str) -> Path:
    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
    output_dir = Path(output_dir)

    geometry_cfg = config["geometry"]
    geometry = compute_element_centers(
        nx=int(geometry_cfg["nx"]),
        ny=int(geometry_cfg["ny"]),
        dx=float(geometry_cfg["dx"]),
        dy=float(geometry_cfg["dy"]),
        origin=geometry_cfg.get("origin"),
        normal=geometry_cfg.get("normal"),
        x_axis_hint=geometry_cfg.get("x_axis_hint"),
    )
    frequency_hz = float(config["experiment"]["frequency_hz"])
    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz

    phase_map = _resolve_phase_map(config, wavelength)
    plots_dir = output_dir / "plots"
    plots_dir.mkdir(parents=True, exist_ok=True)
    data_dir = output_dir / "data"
    data_dir.mkdir(parents=True, exist_ok=True)
    _plot_phase_map(phase_map, plots_dir)
    np.save(data_dir / "phase_map.npy", phase_map)

    run_id = output_dir.name

    if mode == "pattern":
        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
        theta_deg = np.arange(
            float(sweep_cfg["start"]),
            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
            float(sweep_cfg["step"]),
        )
        linear = _compute_array_response(
            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
        )
        normalization = config["pattern_mode"].get("normalization", "peak_0db")
        linear_norm = _apply_normalization(linear, normalization)
        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
        np.save(data_dir / "theta_deg.npy", theta_deg)
        np.save(data_dir / "pattern_linear.npy", linear_norm)
        np.save(data_dir / "pattern_db.npy", pattern_db)
        _plot_pattern(theta_deg, pattern_db, plots_dir)

        peak_idx = int(np.argmax(pattern_db))
        metrics = {
            "run_id": run_id,
            "mode": mode,
            "output_dir": str(output_dir),
            "config_hash": summary["config"]["hash_sha256"],
            "normalization": normalization,
            "peak_angle_deg": float(theta_deg[peak_idx]),
            "peak_db": float(pattern_db[peak_idx]),
            "peak_linear": float(linear_norm[peak_idx]),
        }
    elif mode == "link":
        link_cfg = config.get("link_mode", {})
        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
        linear = _compute_array_response(
            geometry.centers,
            phase_map,
            geometry.frame,
            wavelength,
            np.array([rx_angle], dtype=float),
        )
        metrics = {
            "run_id": run_id,
            "mode": mode,
            "output_dir": str(output_dir),
            "config_hash": summary["config"]["hash_sha256"],
            "rx_angle_deg": rx_angle,
            "link_gain_linear": float(linear[0]),
            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
        }
    else:
        raise ValueError(f"Unsupported run mode: {mode}")

    _write_metrics(output_dir, metrics)
    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
    return output_dir


def validate_ris_lab(config_path: str, ref_path: str) -> Path:
    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
    output_dir = Path(output_dir)

    geometry_cfg = config["geometry"]
    geometry = compute_element_centers(
        nx=int(geometry_cfg["nx"]),
        ny=int(geometry_cfg["ny"]),
        dx=float(geometry_cfg["dx"]),
        dy=float(geometry_cfg["dy"]),
        origin=geometry_cfg.get("origin"),
        normal=geometry_cfg.get("normal"),
        x_axis_hint=geometry_cfg.get("x_axis_hint"),
    )
    frequency_hz = float(config["experiment"]["frequency_hz"])
    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz

    phase_map = _resolve_phase_map(config, wavelength)
    plots_dir = output_dir / "plots"
    plots_dir.mkdir(parents=True, exist_ok=True)
    _plot_phase_map(phase_map, plots_dir)

    ref_path = Path(ref_path)
    if not ref_path.exists():
        raise FileNotFoundError(f"Reference file not found: {ref_path}")
    if ref_path.suffix.lower() != ".csv":
        raise ValueError("Reference file must be a CSV for now")

    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
    sim_linear = _compute_array_response(
        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
    )

    normalization = config.get("validation", {}).get(
        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
    )
    sim_linear_norm = _apply_normalization(sim_linear, normalization)
    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)

    if ref_kind == "pattern_db":
        ref_linear = 10.0 ** (ref_vals / 10.0)
    else:
        ref_linear = ref_vals
    ref_linear_norm = _apply_normalization(ref_linear, normalization)
    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)

    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
    sim_peak_idx = int(np.argmax(sim_db))
    ref_peak_idx = int(np.argmax(ref_db))
    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))

    thresholds = config.get("validation", {})
    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max

    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
    ax.set_title("RIS Validation Overlay")
    ax.set_xlabel("Rx angle [deg]")
    ax.set_ylabel("Gain [dB]")
    ax.legend(loc="best")
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
    plt.close(fig)

    metrics = {
        "run_id": output_dir.name,
        "mode": "validate",
        "output_dir": str(output_dir),
        "config_hash": summary["config"]["hash_sha256"],
        "reference_path": str(ref_path),
        "normalization": normalization,
        "rmse_db": rmse_db,
        "peak_angle_error_deg": peak_angle_error,
        "peak_db_error": peak_db_error,
        "thresholds": {
            "rmse_db_max": rmse_max,
            "peak_angle_err_deg_max": peak_angle_max,
            "peak_db_err_max": peak_db_max,
        },
        "passed": bool(passed),
    }
    _write_metrics(output_dir, metrics)
    logger.info(
        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
    )
    return output_dir
apply_patch(auto_approved=true) exited 0 in 3ms:
Success. Updated the following files:
A /home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_lab.py
file update:
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..e9add62c94b8a76dd462b56ae8cf98499cb24970
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,367 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir

file update:
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..e9add62c94b8a76dd462b56ae8cf98499cb24970
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,367 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Extending CLI with RIS command and subcommands**

Planning to update cli.py by adding a "ris" subparser with "run" and "validate" subcommands and corresponding arguments; then hooking these into main to call RIS functions and log appropriately, ensuring no command conflicts and relying on existing RIS logging while adding extra CLI-level info.
file update
M /home/josh/Documents/Github/RIS_SIONNA/app/cli.py
@@ -51,2 +51,16 @@
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
@@ -131,2 +145,12 @@
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M /home/josh/Documents/Github/RIS_SIONNA/app/cli.py
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..e9add62c94b8a76dd462b56ae8cf98499cb24970
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,367 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir

file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..e9add62c94b8a76dd462b56ae8cf98499cb24970
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,367 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Adding major action logging**

I'll integrate Ralph logging to capture key actions for better traceability in the system.
exec
/usr/bin/zsh -lc 'ralph log "Implemented RIS Lab CLI runner and validation module"' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 87ms:
Using local templates: /home/josh/Documents/Github/RIS_SIONNA/.agents/ralph
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..e9add62c94b8a76dd462b56ae8cf98499cb24970
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,367 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Noticing redundant geometry computation**

The phase map resolution recomputes element centers already computed in the main run, causing redundant geometry calculation that could be optimized by passing precomputed geometry into the resolver.
thinking
**Planning to pass geometry into phase map resolver**

I'll update the phase map resolver to accept precomputed geometry to eliminate redundant computations by modifying its signature and calls accordingly.
file update
M /home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_lab.py
@@ -47,14 +47,6 @@
 
-def _resolve_phase_map(config: Dict[str, Any], wavelength: float) -> np.ndarray:
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
     geometry_cfg = config["geometry"]
-    geometry = compute_element_centers(
-        nx=int(geometry_cfg["nx"]),
-        ny=int(geometry_cfg["ny"]),
-        dx=float(geometry_cfg["dx"]),
-        dy=float(geometry_cfg["dy"]),
-        origin=geometry_cfg.get("origin"),
-        normal=geometry_cfg.get("normal"),
-        x_axis_hint=geometry_cfg.get("x_axis_hint"),
-    )
-
     control_cfg = config.get("control", {})
apply_patch(auto_approved=true) exited 0 in 10ms:
Success. Updated the following files:
M /home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_lab.py
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc076e9d46699e4114ef8085fa8dc376856c81b7
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir

file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..cc076e9d46699e4114ef8085fa8dc376856c81b7
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Updating calls to include geometry**
file update
M /home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_lab.py
@@ -201,3 +201,3 @@
 
-    phase_map = _resolve_phase_map(config, wavelength)
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
     plots_dir = output_dir / "plots"
@@ -284,3 +284,3 @@
 
-    phase_map = _resolve_phase_map(config, wavelength)
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
     plots_dir = output_dir / "plots"
apply_patch(auto_approved=true) exited 0 in 4ms:
Success. Updated the following files:
M /home/josh/Documents/Github/RIS_SIONNA/app/ris/ris_lab.py
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir

file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Validating output paths and logging**

Confirmed plot outputs are saved under the plots subdirectory within output_dir, consistent with existing structure and spec; no need to duplicate in root. Logging in run and validate includes run_id, mode, and output_dir as expected.
thinking
**Confirming CLI behavior and planning tests**

Verified CLI logs include run_id, mode, and output_dir; invalid modes trigger argparse errors with exit code 2. Planning to run pytest and log results afterward as required by the activity log.
exec
/usr/bin/zsh -lc 'python -m pytest' in /home/josh/Documents/Github/RIS_SIONNA exited 127 in 2ms:
zsh:1: command not found: python
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Switching to python3 for tests**

I'm deciding to run tests with `python3 -m pytest` since `python` isn't found, treating this as a required failure without repetitive error logging.
exec
/usr/bin/zsh -lc 'python3 -m pytest' in /home/josh/Documents/Github/RIS_SIONNA exited 1 in 13ms:
/usr/bin/python3: No module named pytest
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Noting pytest setup dependencies**

Pytest is not installed by default, so I'll document this requirement and plan to run tests using the existing .venv Python environment for consistency.
exec
/usr/bin/zsh -lc '.venv/bin/python -m pytest' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 432ms:
============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-9.0.2, pluggy-1.6.0
rootdir: /home/josh/Documents/Github/RIS_SIONNA
configfile: pyproject.toml
collected 11 items

tests/test_alignment.py ..                                               [ 18%]
tests/test_ris_config.py ...                                             [ 45%]
tests/test_ris_core.py ......                                            [100%]

============================== 11 passed in 0.27s ==============================
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Adding post-test logging**
exec
/usr/bin/zsh -lc 'ralph log "Ran pytest via .venv/bin/python"' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 88ms:
Using local templates: /home/josh/Documents/Github/RIS_SIONNA/.agents/ralph
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Preparing for review and logging updates**
exec
/usr/bin/zsh -lc 'git status --porcelain' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 4ms:
 M .agents/tasks/prd-ris-lab.json
 M .ralph/activity.log
 M .ralph/errors.log
 M .ralph/runs/run-20260120-175122-20544-iter-2.log
 M app/cli.py
?? .ralph/.tmp/prompt-20260120-175122-20544-3.md
?? .ralph/.tmp/story-20260120-175122-20544-3.json
?? .ralph/.tmp/story-20260120-175122-20544-3.md
?? .ralph/runs/run-20260120-175122-20544-iter-2.md
?? .ralph/runs/run-20260120-175122-20544-iter-3.log
?? app/ris/ris_lab.py
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Pausing due to unexpected file changes**

Unexpected modifications to product JSON and error logs are detected that weren't made in this iteration; per instructions, progress must pause and the user should be asked how to proceed.
thinking
**Investigating unexpected file modifications**

I'm assessing diffs in the modified product JSON and related files to determine if changes came from prior runs or external tools, aiming to discern if stopping and asking the user is truly required.
exec
/usr/bin/zsh -lc 'git diff --stat' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 8ms:
 .agents/tasks/prd-ris-lab.json                   |   13 +-
 .ralph/activity.log                              |    6 +
 .ralph/errors.log                                |    1 +
 .ralph/runs/run-20260120-175122-20544-iter-2.log | 1282 +++++++++++++++++++++-
 app/cli.py                                       |   24 +
 5 files changed, 1320 insertions(+), 6 deletions(-)
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Flagging unexpected file changes**

The prd json and errors log files changed without direct edits, which conflicts with instructions to stop and ask the user how to proceed; since asking is prohibited, I'll flag this as an unexpected side effect from tools and consider proceeding cautiously.
thinking
**Investigating unexpected prd file changes**

I'll check the prd file diff to determine if its modifications come from the current run or are leftover from earlier, aiming to clarify if it's safe to proceed despite unexpected changes.
exec
/usr/bin/zsh -lc 'git diff .agents/tasks/prd-ris-lab.json' in /home/josh/Documents/Github/RIS_SIONNA succeeded in 4ms:
diff --git a/.agents/tasks/prd-ris-lab.json b/.agents/tasks/prd-ris-lab.json
index 6ac50d3..2977ca6 100644
--- a/.agents/tasks/prd-ris-lab.json
+++ b/.agents/tasks/prd-ris-lab.json
@@ -157,7 +157,7 @@
     {
       "id": "US-002",
       "title": "Define RIS Lab config schema and snapshot outputs",
-      "status": "in_progress",
+      "status": "done",
       "dependsOn": [
         "US-001"
       ],
@@ -169,13 +169,13 @@
         "Config resolution is deterministic and recorded in run metadata (metrics.json or summary.json)"
       ],
       "startedAt": "2026-01-20T17:57:12.190815+00:00",
-      "completedAt": null,
-      "updatedAt": "2026-01-20T17:57:12.190823+00:00"
+      "completedAt": "2026-01-20T18:09:25.595908+00:00",
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Proceeding with pre-existing changes**

The modified files seem to stem from earlier iterations and aren't unexpected changes, so I'll continue without reverting them while noting this in the final summary. Next, I'll focus on adding the new file and ensuring it uses `degrees_to_radians` appropriately.
thinking
**Reviewing log file changes and commit scope**

Noticing .ralph logs changed partially from tools or prior runs, not directly by me this iteration; I'll ensure only files modified during this run—including new logs I created—are committed, avoiding unrelated pre-existing changes. Next, I'll confirm proper logging and commit steps accordingly.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.ralph/errors.log"}) success in 1ms:
{
  "content": [
    {
      "text": "# Error Log\n\n> Failures and repeated issues. Use this to add guardrails.\n\n[2026-01-20 17:57:10] ITERATION 1 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-1.md\n[2026-01-20 18:09:25] ITERATION 2 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-2.md\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "# Error Log\n\n> Failures and repeated issues. Use this to add guardrails.\n\n[2026-01-20 17:57:10] ITERATION 1 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-1.md\n[2026-01-20 18:09:25] ITERATION 2 left uncommitted changes; review run summary at /home/josh/Documents/Github/RIS_SIONNA/.ralph/runs/run-20260120-175122-20544-iter-2.md\n"
  }
}
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Reconciling staging conflicts**

The instructions require staging all changes including preexisting ones, even if that risks committing unrelated modifications; I'll follow this directive strictly despite potential conflicts around untracked or prior changes.
thinking
**Considering .ralph/.tmp handling**

I'm checking if .ralph/.tmp files are ignored by git or meant to be committed; since instructions say to commit all changes made during the run including logs, these temp files might need committing unless explicitly ignored.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.gitignore"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.gitignore"}) success in 1ms:
{
  "content": [
    {
      "text": "__pycache__/\n*.pyc\n.venv/\noutputs/\n.DS_Store\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "__pycache__/\n*.pyc\n.venv/\noutputs/\n.DS_Store\n"
  }
}
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir


thinking
**Confirming staging of temp files and locating entrypoint**

Deciding to include untracked `.ralph` temp files as the process likely expects committing logs and summaries. Now verifying that running `python -m app` uses `app/__main__.py` as the entrypoint.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/__main__.py"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/app/__main__.py"}) success in 1ms:
{
  "content": [
    {
      "text": "from .cli import main\n\nif __name__ == \"__main__\":\n    main()\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "from .cli import main\n\nif __name__ == \"__main__\":\n    main()\n"
  }
}
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Confirming angle conversions and config usage**

I verified `degrees_to_radians` is correctly applied for theta and that `theta_ref` uses CSV order as-is. Polar plots tolerate negative dB radii, so no conversion needed there. The `pattern_mode` config consistently provides needed defaults, and validation aligns with config fallback. I'll document test command issues and finalize reviews later.
thinking
**Logging test command results and considering init updates**

I’ll record both the failed `python -m pytest` attempt and the passing `.venv` run in the progress log to meet requirement transparency. Adding new functions to the module’s `__init__.py` is optional but noted as helpful for usability. Next, I’ll prepare for commit by reviewing diffs and updating logs as needed.
tool filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.codex/skills/commit/SKILL.md"})
filesystem.read_text_file({"path":"/home/josh/Documents/Github/RIS_SIONNA/.codex/skills/commit/SKILL.md"}) success in 1ms:
{
  "content": [
    {
      "text": "---\nname: commit\ndescription: Write conventional commit messages with type, scope, and subject when the user wants to commit changes or save work.\n---\n\n# Git Commit\n\nCreates git commits following Conventional Commits format with proper type, scope, and subject.\n\n## Quick Start\n\n```bash\n# 1. Stage changes\ngit add <files>  # or: git add -A\n\n# 2. Create commit (branch commit format)\ngit commit -m \"type(scope): subject\n\nBody explaining HOW and WHY.\nReference: Task X.Y, Req N\"\n```\n\n## Commit Types\n\n### Regular Branch Commits (During Development)\n\n**Format**: `type(scope): subject`\n\n| Type | Purpose |\n|------|---------|\n| `feat` | New feature or functionality |\n| `fix` | Bug fix or issue resolution |\n| `refactor` | Code refactoring without behavior change |\n| `perf` | Performance improvements |\n| `test` | Test additions or modifications |\n| `ci` | CI/CD configuration changes |\n| `docs` | Documentation updates |\n| `chore` | Maintenance, dependencies, tooling |\n| `style` | Code formatting, linting (non-functional) |\n| `security` | Security vulnerability fixes or hardening |\n\n### Scope (Required, kebab-case)\n\nExamples: `validation`, `auth`, `cookie-service`, `template`, `config`, `tests`, `api`\n\n### Subject Line Rules\n\n- Max 50 characters after colon\n- Present tense imperative: add, implement, fix, improve, enhance, refactor, remove, prevent\n- NO period at the end\n- Specific and descriptive - state WHAT, not WHY\n\n## Core Workflow\n\n### 1. Review Changes\n\n```bash\ngit status\ngit diff --staged  # if already staged\ngit diff           # if not staged\n```\n\n### 2. Stage Files\n\n```bash\ngit add <specific-files>  # preferred\n# or\ngit add -A  # all changes\n```\n\n**NEVER commit**:\n- `.env`, `credentials.json`, secrets\n- `node_modules/`, `__pycache__/`, `.venv/`\n- Large binary files without explicit approval\n\n### 3. Create Commit\n\n**Simple change**:\n```bash\ngit commit -m \"fix(auth): use hmac.compare_digest for secure comparison\"\n```\n\n**Complex change (with body)**:\n```bash\ngit commit -m \"$(cat <<'EOF'\nfeat(validation): add URLValidator with domain whitelist\n\nImplement URLValidator class supporting:\n- Domain whitelist enforcement (youtube.com, youtu.be)\n- Dangerous scheme blocking (javascript, data, file)\n- URL parsing with embedded credentials handling\n\nAddresses Requirement 31: Input validation\nPart of Task 5.1: Input Validation Utilities\nEOF\n)\"\n```\n\n### 4. Verify Commit\n\n```bash\ngit log -1 --format=\"%h %s\"\ngit show --stat HEAD\n```\n\n## Body Format (Recommended for Complex Changes)\n\n```\n<blank line>\nExplain HOW and WHY the change was made.\n- Use bullet points for multiple items\n- Wrap at 72 characters\n\nReference: Task X.Y\nAddresses: Req N\n```\n\n## Git Trailers\n\n| Trailer | Purpose |\n|---------|---------|\n| `Fixes #N` | Links and closes issue on merge |\n| `Closes #N` | Same as Fixes |\n| `Co-authored-by: Name <email>` | Credit co-contributors |\n\nPlace trailers at end of body after blank line. See `references/commit_examples.md` for examples.\n\n## Breaking Changes\n\nFor incompatible API/behavior changes, use `!` after scope OR `BREAKING CHANGE:` footer:\n\n```\nfeat(api)!: change response format to JSON:API\n\nBREAKING CHANGE: Response envelope changed from `{ data }` to `{ data: { type, id, attributes } }`.\n```\n\nTriggers major version bump in semantic-release.\n\n## Merge Commits (PR Closure)\n\nFor PRs, use extended description with sections:\n\n```bash\ngh pr create --title \"feat(security): implement input validation (Task 5)\" --body \"$(cat <<'EOF'\n## Summary\n- Input validation utilities (URLValidator, FormatValidator)\n- Secure template processor with path traversal prevention\n- API key authentication middleware\n\n## Task Breakdown\nTask 5.1: Input Validation - URLValidator, FormatValidator\nTask 5.2: Template Processing - Path traversal prevention\nTask 5.3: API Key Auth - Multi-key support, excluded paths\nTask 5.4: Security Tests - 102 path traversal tests\n\n## Requirements Covered\nReq 7, Req 9, Req 31, Req 33\n\n## Test Coverage\n- All 473 tests passing\n- Coverage: 93%\n- Pre-commit checks: passing\nEOF\n)\"\n```\n\n## Integration with Other Skills\n\n### From github-pr-review\n\nWhen fixing review comments, use this format:\n\n```bash\ngit commit -m \"fix(scope): address review comment #ID\n\nBrief explanation of what was wrong and how it's fixed.\nAddresses review comment #123456789.\"\n```\n\n### From github-pr-creation\n\nBefore creating PR, ensure all commits follow this format. The PR skill will:\n1. Analyze commits for proper format\n2. Extract types for PR labels\n3. Build PR description from commit bodies\n\n## Important Rules\n\n- **ALWAYS** include scope in parentheses\n- **ALWAYS** use present tense imperative verb\n- **NEVER** end subject with period\n- **NEVER** commit secrets or credentials\n- **NEVER** use generic messages (\"update code\", \"fix bug\", \"changes\")\n- **NEVER** exceed 50 chars in subject line\n- Group related changes -> single focused commit\n\n## Examples\n\n**Good**:\n```\nfeat(validation): add URLValidator with domain whitelist\nfix(auth): use hmac.compare_digest for secure key comparison\nrefactor(template): consolidate filename sanitization logic\ntest(security): add 102 path traversal prevention tests\n```\n\n**Bad**:\n```\nupdate validation code           # no type, no scope, vague\nfeat: add stuff                  # missing scope, too vague\nfix(auth): fix bug               # circular, not specific\nchore: make changes              # missing scope, vague\nfeat(security): improve things.  # has period, vague\n```\n\n## References\n\n- `references/commit_examples.md` - Extended examples by type\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "---\nname: commit\ndescription: Write conventional commit messages with type, scope, and subject when the user wants to commit changes or save work.\n---\n\n# Git Commit\n\nCreates git commits following Conventional Commits format with proper type, scope, and subject.\n\n## Quick Start\n\n```bash\n# 1. Stage changes\ngit add <files>  # or: git add -A\n\n# 2. Create commit (branch commit format)\ngit commit -m \"type(scope): subject\n\nBody explaining HOW and WHY.\nReference: Task X.Y, Req N\"\n```\n\n## Commit Types\n\n### Regular Branch Commits (During Development)\n\n**Format**: `type(scope): subject`\n\n| Type | Purpose |\n|------|---------|\n| `feat` | New feature or functionality |\n| `fix` | Bug fix or issue resolution |\n| `refactor` | Code refactoring without behavior change |\n| `perf` | Performance improvements |\n| `test` | Test additions or modifications |\n| `ci` | CI/CD configuration changes |\n| `docs` | Documentation updates |\n| `chore` | Maintenance, dependencies, tooling |\n| `style` | Code formatting, linting (non-functional) |\n| `security` | Security vulnerability fixes or hardening |\n\n### Scope (Required, kebab-case)\n\nExamples: `validation`, `auth`, `cookie-service`, `template`, `config`, `tests`, `api`\n\n### Subject Line Rules\n\n- Max 50 characters after colon\n- Present tense imperative: add, implement, fix, improve, enhance, refactor, remove, prevent\n- NO period at the end\n- Specific and descriptive - state WHAT, not WHY\n\n## Core Workflow\n\n### 1. Review Changes\n\n```bash\ngit status\ngit diff --staged  # if already staged\ngit diff           # if not staged\n```\n\n### 2. Stage Files\n\n```bash\ngit add <specific-files>  # preferred\n# or\ngit add -A  # all changes\n```\n\n**NEVER commit**:\n- `.env`, `credentials.json`, secrets\n- `node_modules/`, `__pycache__/`, `.venv/`\n- Large binary files without explicit approval\n\n### 3. Create Commit\n\n**Simple change**:\n```bash\ngit commit -m \"fix(auth): use hmac.compare_digest for secure comparison\"\n```\n\n**Complex change (with body)**:\n```bash\ngit commit -m \"$(cat <<'EOF'\nfeat(validation): add URLValidator with domain whitelist\n\nImplement URLValidator class supporting:\n- Domain whitelist enforcement (youtube.com, youtu.be)\n- Dangerous scheme blocking (javascript, data, file)\n- URL parsing with embedded credentials handling\n\nAddresses Requirement 31: Input validation\nPart of Task 5.1: Input Validation Utilities\nEOF\n)\"\n```\n\n### 4. Verify Commit\n\n```bash\ngit log -1 --format=\"%h %s\"\ngit show --stat HEAD\n```\n\n## Body Format (Recommended for Complex Changes)\n\n```\n<blank line>\nExplain HOW and WHY the change was made.\n- Use bullet points for multiple items\n- Wrap at 72 characters\n\nReference: Task X.Y\nAddresses: Req N\n```\n\n## Git Trailers\n\n| Trailer | Purpose |\n|---------|---------|\n| `Fixes #N` | Links and closes issue on merge |\n| `Closes #N` | Same as Fixes |\n| `Co-authored-by: Name <email>` | Credit co-contributors |\n\nPlace trailers at end of body after blank line. See `references/commit_examples.md` for examples.\n\n## Breaking Changes\n\nFor incompatible API/behavior changes, use `!` after scope OR `BREAKING CHANGE:` footer:\n\n```\nfeat(api)!: change response format to JSON:API\n\nBREAKING CHANGE: Response envelope changed from `{ data }` to `{ data: { type, id, attributes } }`.\n```\n\nTriggers major version bump in semantic-release.\n\n## Merge Commits (PR Closure)\n\nFor PRs, use extended description with sections:\n\n```bash\ngh pr create --title \"feat(security): implement input validation (Task 5)\" --body \"$(cat <<'EOF'\n## Summary\n- Input validation utilities (URLValidator, FormatValidator)\n- Secure template processor with path traversal prevention\n- API key authentication middleware\n\n## Task Breakdown\nTask 5.1: Input Validation - URLValidator, FormatValidator\nTask 5.2: Template Processing - Path traversal prevention\nTask 5.3: API Key Auth - Multi-key support, excluded paths\nTask 5.4: Security Tests - 102 path traversal tests\n\n## Requirements Covered\nReq 7, Req 9, Req 31, Req 33\n\n## Test Coverage\n- All 473 tests passing\n- Coverage: 93%\n- Pre-commit checks: passing\nEOF\n)\"\n```\n\n## Integration with Other Skills\n\n### From github-pr-review\n\nWhen fixing review comments, use this format:\n\n```bash\ngit commit -m \"fix(scope): address review comment #ID\n\nBrief explanation of what was wrong and how it's fixed.\nAddresses review comment #123456789.\"\n```\n\n### From github-pr-creation\n\nBefore creating PR, ensure all commits follow this format. The PR skill will:\n1. Analyze commits for proper format\n2. Extract types for PR labels\n3. Build PR description from commit bodies\n\n## Important Rules\n\n- **ALWAYS** include scope in parentheses\n- **ALWAYS** use present tense imperative verb\n- **NEVER** end subject with period\n- **NEVER** commit secrets or credentials\n- **NEVER** use generic messages (\"update code\", \"fix bug\", \"changes\")\n- **NEVER** exceed 50 chars in subject line\n- Group related changes -> single focused commit\n\n## Examples\n\n**Good**:\n```\nfeat(validation): add URLValidator with domain whitelist\nfix(auth): use hmac.compare_digest for secure key comparison\nrefactor(template): consolidate filename sanitization logic\ntest(security): add 102 path traversal prevention tests\n```\n\n**Bad**:\n```\nupdate validation code           # no type, no scope, vague\nfeat: add stuff                  # missing scope, too vague\nfix(auth): fix bug               # circular, not specific\nchore: make changes              # missing scope, vague\nfeat(security): improve things.  # has period, vague\n```\n\n## References\n\n- `references/commit_examples.md` - Extended examples by type\n"
  }
}
file update:
diff --git a/app/cli.py b/app/cli.py
index 8e6a687c4cbbcdf50c4ffca23a910774922e28c9..ce5a161d990f55a79f3b1fb908abe7b0f60b1bf5
--- a/app/cli.py
+++ b/app/cli.py
@@ -49,6 +49,20 @@
     sim_p.add_argument("--port", type=int, default=8765, help="Port for the simulator UI")
     sim_p.add_argument("--no-browser", action="store_true", help="Do not open the browser automatically")
 
+    ris_p = subparsers.add_parser("ris", help="RIS Lab tools")
+    ris_subparsers = ris_p.add_subparsers(dest="ris_command", required=True)
+    ris_run = ris_subparsers.add_parser("run", help="Run RIS Lab")
+    ris_run.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_run.add_argument(
+        "--mode",
+        required=True,
+        choices=["pattern", "link"],
+        help="Run mode: pattern or link",
+    )
+    ris_validate = ris_subparsers.add_parser("validate", help="Validate RIS Lab")
+    ris_validate.add_argument("--config", required=True, help="Path to RIS Lab YAML config")
+    ris_validate.add_argument("--ref", required=True, help="Path to reference CSV file")
+
     return parser.parse_args()
 
 
@@ -129,6 +143,16 @@
         serve_simulator(host=args.host, port=int(args.port))
         return
 
+    if args.command == "ris":
+        from .ris.ris_lab import run_ris_lab, validate_ris_lab
+
+        if args.ris_command == "run":
+            run_ris_lab(args.config, args.mode)
+            return
+        if args.ris_command == "validate":
+            validate_ris_lab(args.config, args.ref)
+            return
+
 
 if __name__ == "__main__":
     main()
diff --git a/app/ris/ris_lab.py b/app/ris/ris_lab.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f97b71fb9c63c39b46bb289637b774357eae53
--- /dev/null
+++ b/app/ris/ris_lab.py
@@ -0,0 +1,359 @@
+"""RIS Lab runners for pattern and validation modes."""
+
+from __future__ import annotations
+
+import csv
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+import matplotlib
+matplotlib.use("Agg")
+import matplotlib.pyplot as plt
+import numpy as np
+
+from app.io import save_json
+from app.ris.ris_config import resolve_and_snapshot_ris_lab_config
+from app.ris.ris_core import (
+    compute_element_centers,
+    degrees_to_radians,
+    quantize_phase,
+    synthesize_custom_phase,
+    synthesize_focusing_phase,
+    synthesize_steering_phase,
+    synthesize_uniform_phase,
+)
+
+logger = logging.getLogger(__name__)
+
+_SPEED_OF_LIGHT_M_S = 299_792_458.0
+_DB_FLOOR = 1e-12
+
+
+def _direction_from_angles(azimuth_deg: float, elevation_deg: float) -> np.ndarray:
+    az = float(azimuth_deg)
+    el = float(elevation_deg)
+    az_rad = np.deg2rad(az)
+    el_rad = np.deg2rad(el)
+    return np.array(
+        [
+            np.cos(el_rad) * np.cos(az_rad),
+            np.cos(el_rad) * np.sin(az_rad),
+            np.sin(el_rad),
+        ],
+        dtype=float,
+    )
+
+
+def _resolve_phase_map(
+    config: Dict[str, Any], geometry: Any, wavelength: float
+) -> np.ndarray:
+    geometry_cfg = config["geometry"]
+    control_cfg = config.get("control", {})
+    mode = control_cfg.get("mode", "uniform")
+    params = control_cfg.get("params", {}) or {}
+    shape = (int(geometry_cfg["ny"]), int(geometry_cfg["nx"]))
+
+    if mode == "uniform":
+        if "phase_rad" in params:
+            phase = synthesize_uniform_phase(shape, float(params["phase_rad"]))
+        elif "phase_deg" in params:
+            phase = synthesize_uniform_phase(shape, float(np.deg2rad(params["phase_deg"])))
+        else:
+            phase = synthesize_uniform_phase(shape, 0.0)
+    elif mode == "steer":
+        direction = params.get("direction")
+        if direction is None:
+            az = params.get("azimuth_deg")
+            el = params.get("elevation_deg")
+            if az is None or el is None:
+                raise ValueError(
+                    "steer control requires direction or azimuth_deg/elevation_deg"
+                )
+            direction = _direction_from_angles(float(az), float(el))
+        phase = synthesize_steering_phase(geometry.centers, wavelength, direction)
+    elif mode == "focus":
+        focal_point = params.get("focal_point")
+        if focal_point is None:
+            raise ValueError("focus control requires focal_point")
+        phase = synthesize_focusing_phase(geometry.centers, wavelength, focal_point)
+    elif mode == "custom":
+        phase_map = params.get("phase_map")
+        if phase_map is None:
+            raise ValueError("custom control requires phase_map")
+        phase = synthesize_custom_phase(np.array(phase_map, dtype=float), shape=shape)
+    else:
+        raise ValueError(f"Unsupported control mode: {mode}")
+
+    quant_bits = config.get("quantization", {}).get("bits")
+    phase = quantize_phase(phase, quant_bits)
+    return phase
+
+
+def _compute_array_response(
+    centers: np.ndarray,
+    phase_map: np.ndarray,
+    frame: Any,
+    wavelength: float,
+    theta_deg: np.ndarray,
+) -> np.ndarray:
+    theta_rad = degrees_to_radians(np.array(theta_deg, dtype=float))
+    directions = np.cos(theta_rad)[:, None] * frame.w + np.sin(theta_rad)[:, None] * frame.u
+    centers_flat = centers.reshape(-1, 3)
+    phase_flat = phase_map.reshape(-1)
+    phase_incident = centers_flat @ directions.T
+    total_phase = (2.0 * np.pi / float(wavelength)) * phase_incident + phase_flat[:, None]
+    response = np.exp(1j * total_phase).sum(axis=0)
+    return np.abs(response) ** 2
+
+
+def _apply_normalization(linear: np.ndarray, mode: str | None) -> np.ndarray:
+    if mode is None:
+        return linear
+    if mode == "peak_0db":
+        peak = np.max(linear)
+        return linear / peak if peak > 0 else linear
+    if mode == "unit_power":
+        mean = np.mean(linear)
+        return linear / mean if mean > 0 else linear
+    raise ValueError(f"Unsupported normalization mode: {mode}")
+
+
+def _plot_phase_map(phase_map: np.ndarray, output_dir: Path) -> Path:
+    fig, ax = plt.subplots(figsize=(6, 5))
+    im = ax.imshow(phase_map, origin="lower", cmap="twilight")
+    ax.set_title("RIS Phase Map [rad]")
+    ax.set_xlabel("Element X")
+    ax.set_ylabel("Element Y")
+    fig.colorbar(im, ax=ax, label="Phase [rad]")
+    fig.tight_layout()
+    path = output_dir / "phase_map.png"
+    fig.savefig(path, dpi=200)
+    plt.close(fig)
+    return path
+
+
+def _plot_pattern(theta_deg: np.ndarray, pattern_db: np.ndarray, output_dir: Path) -> Tuple[Path, Path]:
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_deg, pattern_db, color="#005f73", linewidth=2.0)
+    ax.set_title("RIS Pattern (Normalized)")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    cartesian_path = output_dir / "pattern_cartesian.png"
+    fig.savefig(cartesian_path, dpi=200)
+    plt.close(fig)
+
+    fig = plt.figure(figsize=(6, 6))
+    ax = fig.add_subplot(111, projection="polar")
+    ax.plot(np.deg2rad(theta_deg), pattern_db, color="#0a9396", linewidth=2.0)
+    ax.set_title("RIS Pattern (Polar)")
+    ax.set_theta_zero_location("N")
+    ax.set_theta_direction(-1)
+    fig.tight_layout()
+    polar_path = output_dir / "pattern_polar.png"
+    fig.savefig(polar_path, dpi=200)
+    plt.close(fig)
+    return cartesian_path, polar_path
+
+
+def _load_reference_csv(path: Path) -> Tuple[np.ndarray, np.ndarray, str]:
+    with path.open("r", encoding="utf-8") as handle:
+        reader = csv.DictReader(handle)
+        if reader.fieldnames is None:
+            raise ValueError("Reference CSV must include header row")
+        fields = {name.strip() for name in reader.fieldnames}
+        if "theta_deg" not in fields:
+            raise ValueError("Reference CSV missing required column: theta_deg")
+        if "pattern_db" not in fields and "pattern_linear" not in fields:
+            raise ValueError("Reference CSV missing required pattern_db or pattern_linear column")
+
+        theta_vals = []
+        pattern_vals = []
+        pattern_kind = "pattern_db" if "pattern_db" in fields else "pattern_linear"
+        for row in reader:
+            theta_vals.append(float(row["theta_deg"]))
+            pattern_vals.append(float(row[pattern_kind]))
+    return np.array(theta_vals, dtype=float), np.array(pattern_vals, dtype=float), pattern_kind
+
+
+def _write_metrics(output_dir: Path, metrics: Dict[str, Any]) -> None:
+    save_json(output_dir / "metrics.json", metrics)
+
+
+def run_ris_lab(config_path: str, mode: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    data_dir = output_dir / "data"
+    data_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+    np.save(data_dir / "phase_map.npy", phase_map)
+
+    run_id = output_dir.name
+
+    if mode == "pattern":
+        sweep_cfg = config["pattern_mode"]["rx_sweep_deg"]
+        theta_deg = np.arange(
+            float(sweep_cfg["start"]),
+            float(sweep_cfg["stop"]) + float(sweep_cfg["step"]) * 0.5,
+            float(sweep_cfg["step"]),
+        )
+        linear = _compute_array_response(
+            geometry.centers, phase_map, geometry.frame, wavelength, theta_deg
+        )
+        normalization = config["pattern_mode"].get("normalization", "peak_0db")
+        linear_norm = _apply_normalization(linear, normalization)
+        pattern_db = 10.0 * np.log10(linear_norm + _DB_FLOOR)
+        np.save(data_dir / "theta_deg.npy", theta_deg)
+        np.save(data_dir / "pattern_linear.npy", linear_norm)
+        np.save(data_dir / "pattern_db.npy", pattern_db)
+        _plot_pattern(theta_deg, pattern_db, plots_dir)
+
+        peak_idx = int(np.argmax(pattern_db))
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "normalization": normalization,
+            "peak_angle_deg": float(theta_deg[peak_idx]),
+            "peak_db": float(pattern_db[peak_idx]),
+            "peak_linear": float(linear_norm[peak_idx]),
+        }
+    elif mode == "link":
+        link_cfg = config.get("link_mode", {})
+        rx_angle = float(link_cfg.get("rx_angle_deg", 0.0))
+        linear = _compute_array_response(
+            geometry.centers,
+            phase_map,
+            geometry.frame,
+            wavelength,
+            np.array([rx_angle], dtype=float),
+        )
+        metrics = {
+            "run_id": run_id,
+            "mode": mode,
+            "output_dir": str(output_dir),
+            "config_hash": summary["config"]["hash_sha256"],
+            "rx_angle_deg": rx_angle,
+            "link_gain_linear": float(linear[0]),
+            "link_gain_db": float(10.0 * np.log10(linear[0] + _DB_FLOOR)),
+        }
+    else:
+        raise ValueError(f"Unsupported run mode: {mode}")
+
+    _write_metrics(output_dir, metrics)
+    logger.info("RIS Lab run_id=%s mode=%s output_dir=%s", run_id, mode, output_dir)
+    return output_dir
+
+
+def validate_ris_lab(config_path: str, ref_path: str) -> Path:
+    config, output_dir, summary = resolve_and_snapshot_ris_lab_config(config_path)
+    output_dir = Path(output_dir)
+
+    geometry_cfg = config["geometry"]
+    geometry = compute_element_centers(
+        nx=int(geometry_cfg["nx"]),
+        ny=int(geometry_cfg["ny"]),
+        dx=float(geometry_cfg["dx"]),
+        dy=float(geometry_cfg["dy"]),
+        origin=geometry_cfg.get("origin"),
+        normal=geometry_cfg.get("normal"),
+        x_axis_hint=geometry_cfg.get("x_axis_hint"),
+    )
+    frequency_hz = float(config["experiment"]["frequency_hz"])
+    wavelength = _SPEED_OF_LIGHT_M_S / frequency_hz
+
+    phase_map = _resolve_phase_map(config, geometry, wavelength)
+    plots_dir = output_dir / "plots"
+    plots_dir.mkdir(parents=True, exist_ok=True)
+    _plot_phase_map(phase_map, plots_dir)
+
+    ref_path = Path(ref_path)
+    if not ref_path.exists():
+        raise FileNotFoundError(f"Reference file not found: {ref_path}")
+    if ref_path.suffix.lower() != ".csv":
+        raise ValueError("Reference file must be a CSV for now")
+
+    theta_ref, ref_vals, ref_kind = _load_reference_csv(ref_path)
+    sim_linear = _compute_array_response(
+        geometry.centers, phase_map, geometry.frame, wavelength, theta_ref
+    )
+
+    normalization = config.get("validation", {}).get(
+        "normalization", config["pattern_mode"].get("normalization", "peak_0db")
+    )
+    sim_linear_norm = _apply_normalization(sim_linear, normalization)
+    sim_db = 10.0 * np.log10(sim_linear_norm + _DB_FLOOR)
+
+    if ref_kind == "pattern_db":
+        ref_linear = 10.0 ** (ref_vals / 10.0)
+    else:
+        ref_linear = ref_vals
+    ref_linear_norm = _apply_normalization(ref_linear, normalization)
+    ref_db = 10.0 * np.log10(ref_linear_norm + _DB_FLOOR)
+
+    rmse_db = float(np.sqrt(np.mean((sim_db - ref_db) ** 2)))
+    sim_peak_idx = int(np.argmax(sim_db))
+    ref_peak_idx = int(np.argmax(ref_db))
+    peak_angle_error = float(abs(theta_ref[sim_peak_idx] - theta_ref[ref_peak_idx]))
+    peak_db_error = float(abs(sim_db[sim_peak_idx] - ref_db[ref_peak_idx]))
+
+    thresholds = config.get("validation", {})
+    rmse_max = float(thresholds.get("rmse_db_max", 2.0))
+    peak_angle_max = float(thresholds.get("peak_angle_err_deg_max", 2.0))
+    peak_db_max = float(thresholds.get("peak_db_err_max", 1.5))
+    passed = rmse_db <= rmse_max and peak_angle_error <= peak_angle_max and peak_db_error <= peak_db_max
+
+    fig, ax = plt.subplots(figsize=(7, 4))
+    ax.plot(theta_ref, ref_db, color="#9b2226", linewidth=2.0, label="Reference")
+    ax.plot(theta_ref, sim_db, color="#005f73", linewidth=2.0, label="Sim")
+    ax.set_title("RIS Validation Overlay")
+    ax.set_xlabel("Rx angle [deg]")
+    ax.set_ylabel("Gain [dB]")
+    ax.legend(loc="best")
+    ax.grid(True, alpha=0.3)
+    fig.tight_layout()
+    fig.savefig(plots_dir / "validation_overlay.png", dpi=200)
+    plt.close(fig)
+
+    metrics = {
+        "run_id": output_dir.name,
+        "mode": "validate",
+        "output_dir": str(output_dir),
+        "config_hash": summary["config"]["hash_sha256"],
+        "reference_path": str(ref_path),
+        "normalization": normalization,
+        "rmse_db": rmse_db,
+        "peak_angle_error_deg": peak_angle_error,
+        "peak_db_error": peak_db_error,
+        "thresholds": {
+            "rmse_db_max": rmse_max,
+            "peak_angle_err_deg_max": peak_angle_max,
+            "peak_db_err_max": peak_db_max,
+        },
+        "passed": bool(passed),
+    }
+    _write_metrics(output_dir, metrics)
+    logger.info(
+        "RIS Lab run_id=%s mode=validate output_dir=%s", output_dir.name, output_dir
+    )
+    return output_dir



thinking
**Preparing to commit with reviews**

The code passes security, performance, and regression reviews with no major issues; I'll proceed to commit with scope like "ris-lab" and update progress and activity logs accordingly.
thinking
**Staging all changes**

All changes are staged using a full git add -A as planned.
exec
/usr/bin/zsh -lc 'git add -A' in /home/josh/Documents/Github/RIS_SIONNA